Directory structure:
â””â”€â”€ bonesy512-lazily-ai/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ @
    â”œâ”€â”€ AGENTS.md
    â”œâ”€â”€ components.json
    â”œâ”€â”€ drizzle.config.ts
    â”œâ”€â”€ inspect-pdf.mjs
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ middleware.ts
    â”œâ”€â”€ next.config.ts
    â”œâ”€â”€ package.json
    â”œâ”€â”€ postcss.config.mjs
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ vercel-error.md
    â”œâ”€â”€ app/
    â”‚   â”œâ”€â”€ globals.css
    â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”œâ”€â”€ not-found.tsx
    â”‚   â”œâ”€â”€ sitemap.ts
    â”‚   â”œâ”€â”€ (dashboard)/
    â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ terminal.tsx
    â”‚   â”‚   â”œâ”€â”€ dashboard/
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ activity/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ loading.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ billing/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ contracts/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ actions.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ agents.md
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ general/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ security/
    â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â””â”€â”€ pricing/
    â”‚   â”‚       â”œâ”€â”€ page.tsx
    â”‚   â”‚       â””â”€â”€ submit-button.tsx
    â”‚   â”œâ”€â”€ (login)/
    â”‚   â”‚   â”œâ”€â”€ actions.ts
    â”‚   â”‚   â”œâ”€â”€ login.tsx
    â”‚   â”‚   â”œâ”€â”€ sign-in/
    â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â””â”€â”€ sign-up/
    â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”œâ”€â”€ (marketing)/
    â”‚   â”‚   â””â”€â”€ articles/
    â”‚   â”‚       â”œâ”€â”€ page.tsx
    â”‚   â”‚       â””â”€â”€ [slug]/
    â”‚   â”‚           â””â”€â”€ page.tsx
    â”‚   â””â”€â”€ api/
    â”‚       â”œâ”€â”€ properties/
    â”‚       â”‚   â””â”€â”€ route.ts
    â”‚       â”œâ”€â”€ stripe/
    â”‚       â”‚   â”œâ”€â”€ agents.md
    â”‚       â”‚   â”œâ”€â”€ checkout/
    â”‚       â”‚   â”‚   â””â”€â”€ route.ts
    â”‚       â”‚   â””â”€â”€ webhook/
    â”‚       â”‚       â”œâ”€â”€ agents.md
    â”‚       â”‚       â””â”€â”€ route.ts
    â”‚       â”œâ”€â”€ team/
    â”‚       â”‚   â”œâ”€â”€ route.ts
    â”‚       â”‚   â””â”€â”€ credits/
    â”‚       â”‚       â””â”€â”€ route.ts
    â”‚       â””â”€â”€ user/
    â”‚           â””â”€â”€ route.ts
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ dashboard/
    â”‚   â”‚   â”œâ”€â”€ ContractList.tsx
    â”‚   â”‚   â”œâ”€â”€ CreditRefresher.tsx
    â”‚   â”‚   â”œâ”€â”€ CreditsCounter.tsx
    â”‚   â”‚   â”œâ”€â”€ CsvUploadForm.tsx
    â”‚   â”‚   â”œâ”€â”€ DownloadContractButton.tsx
    â”‚   â”‚   â””â”€â”€ UploadErrorViewer.tsx
    â”‚   â””â”€â”€ ui/
    â”‚       â”œâ”€â”€ avatar.tsx
    â”‚       â”œâ”€â”€ button.tsx
    â”‚       â”œâ”€â”€ card.tsx
    â”‚       â”œâ”€â”€ checkbox.tsx
    â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚       â”œâ”€â”€ input.tsx
    â”‚       â”œâ”€â”€ label.tsx
    â”‚       â””â”€â”€ radio-group.tsx
    â”œâ”€â”€ lib/
    â”‚   â”œâ”€â”€ data.ts
    â”‚   â”œâ”€â”€ definitions.ts
    â”‚   â”œâ”€â”€ posts.ts
    â”‚   â”œâ”€â”€ utils.ts
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”œâ”€â”€ middleware.ts
    â”‚   â”‚   â””â”€â”€ session.ts
    â”‚   â”œâ”€â”€ content/
    â”‚   â”‚   â””â”€â”€ posts.ts
    â”‚   â”œâ”€â”€ contracts/
    â”‚   â”‚   â”œâ”€â”€ agents.md
    â”‚   â”‚   â”œâ”€â”€ transformation.ts
    â”‚   â”‚   â””â”€â”€ validation.ts
    â”‚   â”œâ”€â”€ db/
    â”‚   â”‚   â”œâ”€â”€ agents.md
    â”‚   â”‚   â”œâ”€â”€ drizzle.ts
    â”‚   â”‚   â”œâ”€â”€ queries.ts
    â”‚   â”‚   â”œâ”€â”€ schema.ts
    â”‚   â”‚   â”œâ”€â”€ seed.ts
    â”‚   â”‚   â”œâ”€â”€ setup.ts
    â”‚   â”‚   â””â”€â”€ migrations/
    â”‚   â”‚       â”œâ”€â”€ 0000_soft_the_anarchist.sql
    â”‚   â”‚       â”œâ”€â”€ 0001_mixed_lilith.sql
    â”‚   â”‚       â”œâ”€â”€ 0002_regular_madelyne_pryor.sql
    â”‚   â”‚       â”œâ”€â”€ 0003_tidy_omega_flight.sql
    â”‚   â”‚       â”œâ”€â”€ 0004_lonely_lethal_legion.sql
    â”‚   â”‚       â””â”€â”€ meta/
    â”‚   â”‚           â”œâ”€â”€ 0000_snapshot.json
    â”‚   â”‚           â”œâ”€â”€ 0001_snapshot.json
    â”‚   â”‚           â”œâ”€â”€ 0002_snapshot.json
    â”‚   â”‚           â”œâ”€â”€ 0003_snapshot.json
    â”‚   â”‚           â”œâ”€â”€ 0004_snapshot.json
    â”‚   â”‚           â””â”€â”€ _journal.json
    â”‚   â”œâ”€â”€ mappings/
    â”‚   â”‚   â”œâ”€â”€ trec-1-4-data-json.txt
    â”‚   â”‚   â””â”€â”€ trec-1-4-data.json
    â”‚   â”œâ”€â”€ payments/
    â”‚   â”‚   â”œâ”€â”€ actions.ts
    â”‚   â”‚   â”œâ”€â”€ agents.md
    â”‚   â”‚   â””â”€â”€ stripe.ts
    â”‚   â”œâ”€â”€ properties/
    â”‚   â”‚   â”œâ”€â”€ queries.ts
    â”‚   â”‚   â””â”€â”€ validation.ts
    â”‚   â””â”€â”€ styles/
    â”‚       â””â”€â”€ utils.ts
    â”œâ”€â”€ posts/
    â”‚   â”œâ”€â”€ guide-to-texas-option-fee.mdx
    â”‚   â””â”€â”€ how-to-fill-trec-1-4-wholesale.mdx
    â””â”€â”€ public/
        â””â”€â”€ templates/
            â””â”€â”€ lazily-ai-template.csv

================================================
FILE: README.md
================================================
# Lazily.AI: The Effortless TREC Contract Engine

Lazily.AI is a specialized SaaS platform built to automate the generation of Texas Real Estate Commission (TREC) 1-4 Family Residential Contracts. Designed for real estate investors, wholesalers, and agents, it allows users to upload a CSV of property data and instantly generate hundreds of compliant, filled-out PDF contracts.

The platform utilizes a hybrid billing model: a low monthly subscription for access and a pay-as-you-go credit system for contract generation.

**Live Site: [https://lazily.ai](https://lazily.ai)**

## Key Features

- **CSV to PDF Automation:** Bulk generate TREC 1-4 contracts from a single spreadsheet upload.
- **Robust Data Validation:** Backend validation using Zod schemas to ensure CSV data integrity and contract compliance before generation.
- **Dynamic PDF Generation:** Utilizes `pdf-lib` to programmatically fill and flatten the official TREC PDF template.
- **Hybrid Payment Model:** Integrates Stripe for both recurring monthly subscriptions (`mode: 'subscription'`) and one-time credit pack purchases (`mode: 'payment'`).
- **Authentication & Teams:** Secure user accounts (JWT/cookies) with team management and role-based access (Owner/Member).
- **Dashboard:** Manage generated contracts, monitor available credits, upload CSVs, and handle billing via the Stripe Customer Portal.
- **Activity Logging:** System for tracking key user events (logins, purchases, contract generations).

## Tech Stack

- **Framework**: [Next.js](https://nextjs.org/) (App Router, Server Actions)
- **Database**: [Postgres](https://www.postgresql.org/) (e.g., Vercel Postgres)
- **ORM**: [Drizzle ORM](https://orm.drizzle.team/)
- **Payments**: [Stripe](https://stripe.com/)
- **UI Library**: [shadcn/ui](https://ui.shadcn.com/) & Tailwind CSS
- **Validation**: [Zod](https://zod.dev/)
- **CSV Parsing**: [Papa Parse](https://www.papaparse.com/)
- **PDF Manipulation**: [pdf-lib](https://pdf-lib.js.org/)

## Core Workflow

1.  **Upload:** The user uploads a CSV file matching the required template (`public/templates/lazily-ai-template.csv`).
2.  **Parse & Validate:** The backend parses the CSV (Papa Parse) and validates every row against a comprehensive Zod schema (`lib/contracts/validation.ts`).
3.  **Credit Check:** The system verifies the team has sufficient credits for the number of rows uploaded.
4.  **Persist Data:** Validated contract data is saved to the `contracts` table, and credits are deducted within a database transaction.
5.  **Generate (On-Demand):** When the user clicks "Download," the application retrieves the saved data and generates the PDF using `pdf-lib` and the TREC template (`lib/templates/TREC-20-18-automated-v1.pdf`).

## Key File Structure

- `lib/db/schema.ts`: Database schema (Users, Teams, Contracts, Credits) and relations.
- `lib/contracts/validation.ts`: The core Zod schema defining the required TREC 1-4 data structure.
- `lib/contracts/transformation.ts`: Logic for mapping raw CSV rows to the validated JSON structure.
- `app/(login)/actions.ts`: Contains the `processCsvFile` Server Action (handles upload, validation, credit deduction, and DB insertion).
- `app/(dashboard)/dashboard/contracts/actions.ts`: Contains the `generateContractAction` (handles PDF generation using `pdf-lib`).
- `app/api/stripe/webhook/route.ts`: Handles Stripe events (subscriptions and credit purchases).
- `lib/payments/stripe.ts`: Stripe API configuration and session creation logic.

## Getting Started

Clone the repository and install dependencies:

```bash
git clone [YOUR_REPOSITORY_URL_HERE]
cd lazily-ai
pnpm install


================================================
FILE: @
================================================
[Empty file]


================================================
FILE: AGENTS.md
================================================
# Lazily.AI Agent Guide

This document provides guidance for AI agents working on the Lazily.AI codebase.

## 1. Project Overview

Lazily.AI is a SaaS platform designed to automate the generation of Texas Real Estate Commission (TREC) 1-4 Family Residential Contracts. It allows real estate professionals to upload a CSV file with property data and receive filled-out, compliant PDF contracts.

The platform uses a hybrid billing model with a monthly subscription for access and a pay-as-you-go credit system for generating contracts.

**Core Workflow:**

1.  **Upload CSV:** User uploads a CSV file (`public/templates/lazily-ai-template.csv`).
2.  **Parse & Validate:** The backend parses the CSV and validates each row against a Zod schema.
3.  **Credit Check:** The system verifies the user's team has enough credits.
4.  **Save Data:** Valid contract data is stored in the database, and credits are deducted.
5.  **Generate PDF:** When the user requests a download, the system generates the PDF using `pdf-lib`.

## 2. Tech Stack & Key Libraries

- **Framework:** [Next.js](https://nextjs.org/) (App Router)
- **Database:** [Postgres](https://www.postgresql.org/)
- **ORM:** [Drizzle ORM](https://orm.drizzle.team/)
- **Payments:** [Stripe](https://stripe.com/)
- **UI:** [shadcn/ui](https://ui.shadcn.com/) & Tailwind CSS
- **Validation:** [Zod](https://zod.dev/)
- **CSV Parsing:** [Papa Parse](https://www.papaparse.com/)
- **PDF Manipulation:** [pdf-lib](https://pdf-lib.js.org/)
- **Authentication:** JWT/cookies using `jose`.

## 3. Core Concepts

### Data Validation

The single source of truth for contract data structure is the Zod schema located in `lib/contracts/validation.ts`. All data from the uploaded CSV must be transformed and validated against this schema before being saved to the database.

### Payment System

- **Subscriptions:** Managed by Stripe (`mode: 'subscription'`). Grants access to the platform.
- **Credits:** One-time purchases managed by Stripe (`mode: 'payment'`). Used to generate contracts.
- **Stripe Webhooks:** The endpoint at `app/api/stripe/webhook/route.ts` handles events from Stripe to update subscription statuses and credit balances.

### Server Actions

The application uses Next.js Server Actions for most backend operations that are initiated from the client. This keeps client-side JavaScript minimal and colocates data mutations with the components that use them.

## 4. Key File Structure

- `AGENTS.md`: This file. Your guide to the repository.
- `README.md`: Public-facing project information.
- `package.json`: Project scripts and dependencies.
- `next.config.ts`: Next.js configuration.
- `drizzle.config.ts`: Drizzle ORM configuration.
- `lib/db/schema.ts`: The complete database schema defined with Drizzle ORM.
- `lib/contracts/validation.ts`: The master Zod schema for TREC contract data.
- `lib/contracts/transformation.ts`: Logic for mapping CSV rows to the structure defined by the Zod schema.
- `app/(login)/actions.ts`: Contains the `processCsvFile` Server Action, which is the entry point for the core CSV processing workflow.
- `app/(dashboard)/dashboard/contracts/actions.ts`: Contains the `generateContractAction` for creating the PDF on demand.
- `app/api/stripe/webhook/route.ts`: Handles all incoming Stripe webhooks for payments and subscriptions.

## 5. Development Workflow

### Getting Started

1.  Clone the repository.
2.  Install dependencies using pnpm:
    ```bash
    pnpm install
    ```
3.  Set up your local environment variables by creating a `.env.local` file. You will need credentials for your local Postgres database and Stripe.
4.  Run the development server:
    ```bash
    pnpm dev
    ```

### Database

- **Schema:** The database schema is defined in `lib/db/schema.ts`.
- **Migrations:** To generate a new migration after changing the schema, run:
  ```bash
  pnpm db:generate
  ```
- **Applying Migrations:** To apply migrations to your database, run:
  ```bash
  pnpm db:migrate
  ```
- **Seeding:** To seed the database with initial data, run:
  ```bash
  pnpm db:seed
  ```
- **Database Studio:** To view and manage your database with a GUI, run:
  ```bash
  pnpm db:studio
  ```

## 6. Coding Conventions

- **Use Server Actions:** For any backend logic triggered by user interaction (e.g., form submissions), prefer Next.js Server Actions over traditional API routes.
- **Validate with Zod:** All external data (e.g., from CSV uploads or user input) must be validated using a Zod schema.
- **Use Drizzle ORM:** All database queries should be made using the Drizzle ORM. Refer to the schema in `lib/db/schema.ts` and existing queries in `lib/db/queries.ts`.
- **Follow Existing Patterns:** When adding new features, look for existing implementations of similar features in the codebase and follow the established patterns.
- **Keep UI and Logic Separate:** UI components are in `components/`. Business logic is primarily in `lib/` and `app/` (within actions and routes).



================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: drizzle.config.ts
================================================
import type { Config } from 'drizzle-kit';

export default {
  schema: './lib/db/schema.ts',
  out: './lib/db/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.POSTGRES_URL!,
  },
} satisfies Config;



================================================
FILE: inspect-pdf.mjs
================================================
// inspect-pdf.mjs

import { PDFDocument } from 'pdf-lib';
import fs from 'fs/promises';
import path from 'path';

async function getPdfFieldNames() {
  try {
    console.log('Loading PDF template...');
    const templatePath = path.join(process.cwd(), 'lib/templates/TREC-20-18-automated-v1.pdf');
    const pdfTemplateBytes = await fs.readFile(templatePath);

    const pdfDoc = await PDFDocument.load(pdfTemplateBytes);
    const form = pdfDoc.getForm();
    const fields = form.getFields();

    console.log('--- ðŸ“‹ TREC 1-4 Form Fields ---');
    fields.forEach(field => {
      const type = field.constructor.name;
      const name = field.getName();
      console.log(`${name} (Type: ${type})`);
    });
    console.log('-----------------------------');
    console.log(`âœ… Found ${fields.length} fields.`);

  } catch (error) {
    console.error('Error inspecting PDF:', error);
  }
}

getPdfFieldNames();


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 Vercel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: middleware.ts
================================================
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { signToken, verifyToken } from '@/lib/auth/session';

const protectedRoutes = '/dashboard';

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // THIS IS THE FIX:
  // If the request is for the Stripe webhook, let it pass through immediately.
  if (pathname.startsWith('/api/stripe/webhook')) {
    return NextResponse.next();
  }

  const sessionCookie = request.cookies.get('session');
  const isProtectedRoute = pathname.startsWith(protectedRoutes);

  if (isProtectedRoute && !sessionCookie) {
    return NextResponse.redirect(new URL('/sign-in', request.url));
  }

  let res = NextResponse.next();

  if (sessionCookie && request.method === 'GET') {
    try {
      const parsed = await verifyToken(sessionCookie.value);
      const expiresInOneDay = new Date(Date.now() + 24 * 60 * 60 * 1000);
      res.cookies.set({
        name: 'session',
        value: await signToken({
          ...parsed,
          expires: expiresInOneDay.toISOString()
        }),
        httpOnly: true,
        secure: true,
        sameSite: 'lax',
        expires: expiresInOneDay
      });
    } catch (error) {
      console.error('Error updating session:', error);
      res.cookies.delete('session');
      if (isProtectedRoute) {
        return NextResponse.redirect(new URL('/sign-in', request.url));
      }
    }
  }

  return res;
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
  runtime: 'nodejs'
};


================================================
FILE: next.config.ts
================================================
/** @type {import('next').NextConfig} */
const nextConfig = {
  trailingSlash: false,
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
      },
    ],
  },
};

export default nextConfig;


================================================
FILE: package.json
================================================
{
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "db:setup": "npx tsx lib/db/setup.ts",
    "db:seed": "npx tsx lib/db/seed.ts",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio"
  },
  "dependencies": {
    "@radix-ui/react-checkbox": "^1.3.2",
    "@tailwindcss/postcss": "4.1.7",
    "@types/node": "^22.15.18",
    "@types/react": "19.1.4",
    "@types/react-dom": "19.1.5",
    "@vercel/analytics": "^1.5.0",
    "@vercel/speed-insights": "^1.2.0",
    "autoprefixer": "^10.4.21",
    "bcryptjs": "^3.0.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^16.5.0",
    "drizzle-kit": "^0.31.1",
    "drizzle-orm": "^0.43.1",
    "gray-matter": "^4.0.3",
    "jose": "^6.0.11",
    "lucide-react": "^0.511.0",
    "next": "15.4.4",
    "next-mdx-remote": "^5.0.0",
    "papaparse": "^5.5.3",
    "pdf-lib": "^1.17.1",
    "postcss": "^8.5.3",
    "postgres": "^3.4.5",
    "radix-ui": "^1.4.2",
    "react": "19.1.1",
    "react-dom": "19.1.1",
    "server-only": "^0.0.1",
    "stripe": "^18.1.0",
    "swr": "^2.3.3",
    "tailwind-merge": "^3.3.0",
    "tailwindcss": "4.1.7",
    "tw-animate-css": "^1.3.0",
    "typescript": "^5.8.3",
    "zod": "^3.24.4"
  },
  "devDependencies": {
    "@types/papaparse": "^5.3.16"
  },
  "packageManager": "pnpm@10.14.0+sha512.ad27a79641b49c3e481a16a805baa71817a04bbe06a38d17e60e2eaee83f6a146c6a688125f5792e48dd5ba30e7da52a5cda4c3992b9ccf333f9ce223af84748"
}



================================================
FILE: postcss.config.mjs
================================================
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}



================================================
FILE: vercel-error.md
================================================
[Binary file]


================================================
FILE: app/globals.css
================================================
@import "tailwindcss";
/*
  ---break---
*/
@custom-variant dark (&:is(.dark *));

@import "tw-animate-css";

@variant dark (&:is(.dark *));

@theme {
  --color-background: hsl(var(--background));
  --color-foreground: hsl(var(--foreground));

  --color-card: hsl(var(--card));
  --color-card-foreground: hsl(var(--card-foreground));

  --color-popover: hsl(var(--popover));
  --color-popover-foreground: hsl(var(--popover-foreground));

  --color-primary: hsl(var(--primary));
  --color-primary-foreground: hsl(var(--primary-foreground));

  --color-secondary: hsl(var(--secondary));
  --color-secondary-foreground: hsl(var(--secondary-foreground));

  --color-muted: hsl(var(--muted));
  --color-muted-foreground: hsl(var(--muted-foreground));

  --color-accent: hsl(var(--accent));
  --color-accent-foreground: hsl(var(--accent-foreground));

  --color-destructive: hsl(var(--destructive));
  --color-destructive-foreground: hsl(var(--destructive-foreground));

  --color-border: hsl(var(--border));
  --color-input: hsl(var(--input));
  --color-ring: hsl(var(--ring));

  --color-chart-1: hsl(var(--chart-1));
  --color-chart-2: hsl(var(--chart-2));
  --color-chart-3: hsl(var(--chart-3));
  --color-chart-4: hsl(var(--chart-4));
  --color-chart-5: hsl(var(--chart-5));

  --color-sidebar: hsl(var(--sidebar-background));
  --color-sidebar-foreground: hsl(var(--sidebar-foreground));
  --color-sidebar-primary: hsl(var(--sidebar-primary));
  --color-sidebar-primary-foreground: hsl(var(--sidebar-primary-foreground));
  --color-sidebar-accent: hsl(var(--sidebar-accent));
  --color-sidebar-accent-foreground: hsl(var(--sidebar-accent-foreground));
  --color-sidebar-border: hsl(var(--sidebar-border));
  --color-sidebar-ring: hsl(var(--sidebar-ring));

  --radius-lg: var(--radius);
  --radius-md: calc(var(--radius) - 2px);
  --radius-sm: calc(var(--radius) - 4px);
}

/*
  The default border color has changed to `currentColor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentColor);
  }
}

@layer utilities {
  body {
    font-family: "Manrope", Arial, Helvetica, sans-serif;
  }
}


/*****************************************************************/
/* START OF LAZILY.AI THEME                   */
/* This is the primary block of code that has been updated.    */
/*****************************************************************/
@layer base {
  :root {
    --background: 30 33% 98%;      /* Paper White */
    --foreground: 18 11% 26%;      /* Deep Brown */
    
    --card: 30 20% 96%;            /* Light Beige */
    --card-foreground: 18 11% 26%; /* Deep Brown */
    
    --popover: 30 33% 98%;         /* Paper White */
    --popover-foreground: 18 11% 26%; /* Deep Brown */
    
    --primary: 30 59% 63%;         /* Primary Orange-Tan */
    --primary-foreground: 18 11% 20%; /* Deep Brown for text on primary */
    
    --secondary: 30 20% 96%;       /* Light Beige */
    --secondary-foreground: 18 11% 26%; /* Deep Brown */
    
    --muted: 27 15% 85%;           /* Muted Brown for placeholder text */
    --muted-foreground: 27 9% 55%;

    --accent: 155 18% 46%;         /* Accent Teal */
    --accent-foreground: 30 33% 98%; /* Paper White */
    
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 98%;

    --border: 30 20% 90%;          /* Border Beige */
    --input: 30 20% 90%;           /* Border Beige */
    --ring: 30 59% 63%;            /* Primary Orange-Tan for focus rings */
    
    --chart-1: 30 59% 63%;
    --chart-2: 18 11% 26%;
    --chart-3: 155 18% 46%;
    --chart-4: 30 20% 70%;
    --chart-5: 27 9% 55%;
    
    --radius: 0.5rem;
  }

  .dark {
    --background: 18 11% 15%;      /* Darker version of Deep Brown */
    --foreground: 30 20% 90%;      /* Lighter version of Border Beige */
    
    --card: 18 11% 20%;
    --card-foreground: 30 20% 90%;
    
    --popover: 18 11% 15%;
    --popover-foreground: 30 20% 90%;
    
    --primary: 30 59% 63%;         /* Primary Orange-Tan stays vibrant */
    --primary-foreground: 18 11% 15%; /* Dark text on primary button */
    
    --secondary: 18 11% 25%;
    --secondary-foreground: 30 20% 90%;
    
    --muted: 18 11% 30%;
    --muted-foreground: 30 20% 70%;
    
    --accent: 155 18% 46%;         /* Accent Teal stays vibrant */
    --accent-foreground: 30 33% 98%;
    
    --destructive: 0 63% 31%;
    --destructive-foreground: 0 0% 98%;

    --border: 18 11% 25%;
    --input: 18 11% 25%;
    --ring: 30 59% 63%;            /* Primary Orange-Tan for focus rings */
  }
}
/*****************************************************************/
/* END OF LAZILY.AI THEME                    */
/*****************************************************************/


@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* --- The rest of the file is structural and can remain as is. --- */


================================================
FILE: app/layout.tsx
================================================
import './globals.css';
import type { Metadata, Viewport } from 'next';
import { Manrope } from 'next/font/google';
import { getUser, getTeamForUser } from '@/lib/db/queries';
import { SWRConfig } from 'swr';
import { Analytics } from '@vercel/analytics/next';
import { SpeedInsights } from '@vercel/speed-insights/next';

// --- SEO OPTIMIZED METADATA ---
// This section has been updated to align with the SEO strategy.
export const metadata: Metadata = {
  title: {
    template: '%s | Lazily.AI',
    default: 'Lazily.ai: The Effortless TREC Contract Engine', // Optimized Title
  },
  description: 'Stop spending hours on paperwork. Lazily.ai uses AI to generate hundreds of compliant TREC 1-4 contracts from a single CSV. Effortlessly Done.', // Optimized Description
  openGraph: {
    title: 'Lazily.ai: The Effortless TREC Contract Engine', // Consistent OG Title
    description: 'Stop spending hours on paperwork. Lazily.ai uses AI to generate hundreds of compliant TREC 1-4 contracts from a single CSV. Effortlessly Done.', // Consistent OG Description
    url: 'https://lazily.ai',
    siteName: 'Lazily.AI',
    images: [
      {
        url: 'https://lazily.ai/og-image.png',
        width: 1200,
        height: 630,
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Lazily.ai: The Effortless TREC Contract Engine', // Consistent Twitter Title
    description: 'Stop spending hours on paperwork. Lazily.ai uses AI to generate hundreds of compliant TREC 1-4 contracts from a single CSV. Effortlessly Done.', // Consistent Twitter Description
    images: ['https://lazily.ai/twitter-image.png'],
  },
};

export const viewport: Viewport = {
  maximumScale: 1
};

const manrope = Manrope({ subsets: ['latin'] });

// Helper component for the JSON-LD Schema
function JsonLd() {
  const schema = {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "Lazily.AI",
    "operatingSystem": "WEB",
    "applicationCategory": "BusinessApplication",
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "5.0",
      "ratingCount": "25" // Placeholder - update as you get reviews
    },
    "offers": {
      "@type": "Offer",
      "price": "10.00",
      "priceCurrency": "USD",
      "description": "$10/month subscription plus pay-as-you-go credits for contract generation."
    },
    "description": "Lazily.AI is a SaaS platform that automates the generation of TREC 1-4 real estate contracts for Texas professionals, enabling bulk creation from a single CSV file.",
    "url": "https://lazily.ai",
    "author": {
      "@type": "Organization",
      "name": "Lazily.AI"
    }
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
    />
  );
}


export default function RootLayout({
  children
}: {
  children: React.ReactNode;
}) {
  return (
    <html
      lang="en"
      className={`bg-white dark:bg-slate-950 text-black dark:text-white ${manrope.className}`}
    >
      <body className="min-h-[100dvh] bg-gray-50 dark:bg-slate-900">
        <SWRConfig
          value={{
            fallback: {
              '/api/user': getUser(),
              '/api/team': getTeamForUser()
            }
          }}
        >
          {children}
        </SWRConfig>
        <Analytics />
        <SpeedInsights />
        <JsonLd />
      </body>
    </html>
  );
}



================================================
FILE: app/not-found.tsx
================================================
import Link from 'next/link';
import { CircleIcon } from 'lucide-react';

export default function NotFound() {
  return (
    <div className="flex items-center justify-center min-h-[100dvh]">
      <div className="max-w-md space-y-8 p-4 text-center">
        <div className="flex justify-center">
          <CircleIcon className="size-12 text-orange-500" />
        </div>
        <h1 className="text-4xl font-bold text-gray-900 tracking-tight">
          Page Not Found
        </h1>
        <p className="text-base text-gray-500">
          The page you are looking for might have been removed, had its name
          changed, or is temporarily unavailable.
        </p>
        <Link
          href="/"
          className="max-w-48 mx-auto flex justify-center py-2 px-4 border border-gray-300 rounded-full shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500"
        >
          Back to Home
        </Link>
      </div>
    </div>
  );
}



================================================
FILE: app/sitemap.ts
================================================
import { MetadataRoute } from 'next';
import { getSortedPostsData } from '@/lib/content/posts';

export default function sitemap(): MetadataRoute.Sitemap {
  const siteUrl = 'https://lazily.ai';

  // Get all posts
  const posts = getSortedPostsData();

  // Create sitemap entries for each article
  const articleRoutes = posts.map((post) => {
    let lastModifiedDate: Date;

    // Validate if post.date is a valid string and can be parsed into a Date
    if (typeof post.date === 'string' && post.date.trim() !== '') {
      const parsedDate = new Date(post.date);
      // Check if the parsed date is actually valid (not "Invalid Date")
      if (!isNaN(parsedDate.getTime())) { // getTime() returns NaN for an invalid Date object
        lastModifiedDate = parsedDate;
      } else {
        // Fallback for unparsable but non-empty strings
        console.warn(`Invalid date format for post slug: ${post.slug}. Date string: "${post.date}". Using current date as fallback.`);
        lastModifiedDate = new Date();
      }
    } else {
      // Fallback for empty, null, or undefined dates
      console.warn(`Missing or empty date for post slug: ${post.slug}. Using current date as fallback.`);
      lastModifiedDate = new Date();
    }

    return {
      url: `${siteUrl}/articles/${post.slug}`,
      lastModified: lastModifiedDate,
      changeFrequency: 'monthly' as 'monthly',
      priority: 0.8,
    };
  });

  // Define your other static routes
  const staticRoutes = [
    {
      url: siteUrl,
      lastModified: new Date(),
      changeFrequency: 'yearly' as 'yearly',
      priority: 1,
    },
    {
      url: `${siteUrl}/pricing`,
      lastModified: new Date(),
      changeFrequency: 'monthly' as 'monthly',
      priority: 0.8,
    },
    {
      url: `${siteUrl}/articles`, // The main articles page
      lastModified: new Date(),
      changeFrequency: 'weekly' as 'weekly',
      priority: 0.9,
    },
  ];

  return [...staticRoutes, ...articleRoutes];
}


================================================
FILE: app/(dashboard)/layout.tsx
================================================
'use client';

import Link from 'next/link';
import Image from 'next/image';
import { use, useState, Suspense } from 'react';
import { Button } from '@/components/ui/button';
import { Home, LogOut } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger
} from '@/components/ui/dropdown-menu';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { signOut } from '@/app/(login)/actions';
import { useRouter } from 'next/navigation';
import { User } from '@/lib/db/schema';
import useSWR, { mutate } from 'swr';

const fetcher = (url: string) => fetch(url).then((res) => res.json());

function UserMenu() {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const { data: user } = useSWR<User>('/api/user', fetcher); // `useSWR` is typically for client-side data fetching [1]
  const router = useRouter(); // `useRouter` is a Client Component hook in the App Router [2, 3]

  async function handleSignOut() {
    await signOut(); // This function likely performs data mutation via a Server Action [4]
    mutate('/api/user');
    router.push('/'); // `router.push` enables client-side navigation [3]
  }

  if (!user) {
    // Links displayed for unauthenticated users
    return (
      <>
        {/* NEW: Articles link added here */}
        <Link
          href="/articles"
          className="text-sm font-medium text-foreground/80 hover:text-foreground"
        >
          Articles
        </Link>
        <Link
          href="/pricing"
          className="text-sm font-medium text-foreground/80 hover:text-foreground"
        >
          Pricing
        </Link>
        <Button asChild className="rounded-full" variant="secondary">
          <Link href="/sign-up">Sign Up</Link>
        </Button>
        <Button asChild className="rounded-full">
          <Link href="/sign-in">Sign In</Link>
        </Button>
      </>
    );
  }

  // Dropdown menu for authenticated users
  return (
    <DropdownMenu open={isMenuOpen} onOpenChange={setIsMenuOpen}>
      <DropdownMenuTrigger>
        <Avatar className="cursor-pointer size-9">
          <AvatarImage alt={user.name || ''} />
          <AvatarFallback>
            {user.email
              .split(' ')
              .map((n) => n)
              .join('')}
          </AvatarFallback>
        </Avatar>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="flex flex-col gap-1">
        <DropdownMenuItem className="cursor-pointer">
          <Link href="/dashboard" className="flex w-full items-center">
            <Home className="mr-2 h-4 w-4" />
            <span>Dashboard</span>
          </Link>
        </DropdownMenuItem>
        <form action={handleSignOut} className="w-full">
          <button type="submit" className="flex w-full">
            <DropdownMenuItem className="w-full flex-1 cursor-pointer">
              <LogOut className="mr-2 h-4 w-4" />
              <span>Sign out</span>
            </DropdownMenuItem>
          </button>
        </form>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function Header() {
  return (
    // THE FIX IS HERE: Changed z-50 to z-[100] to ensure it's on top of all other content
    <header className="border-b border-border/50 bg-background/80 backdrop-blur-sm sticky top-0 z-50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
        <Link href="/" className="flex items-center">
          <Image
            src="/Lazily-Text.png"
            alt="Lazily.AI Logo"
            width={120}
            height={32}
            className="h-8 w-auto"
            priority
          />
        </Link>
        <div className="flex items-center space-x-4">
          <Suspense fallback={<div className="h-9" />}>
           <UserMenu />
          </Suspense>
        </div>
      </div>
    </header>
  );
}

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <section className="flex flex-col min-h-screen">
      <Header />
      {children}
    </section>
  );
}


================================================
FILE: app/(dashboard)/page.tsx
================================================
import { Button } from '@/components/ui/button';
import { ArrowRight, Search, FileText, Workflow, Zap } from 'lucide-react';
import Image from 'next/image';
import Link from 'next/link';

export default function HomePage() {
  return (
    <main>
      {/* Hero Section */}
      <section className="py-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:grid lg:grid-cols-12 lg:gap-16 items-center">
            <div className="sm:text-center md:max-w-2xl md:mx-auto lg:col-span-6 lg:text-left">
              <h1 className="text-4xl font-bold text-foreground tracking-tight sm:text-5xl md:text-6xl">
                Automate the TREC 1-4.
                <span className="block text-primary">Instantly.</span>
              </h1>
              <p className="mt-3 text-base text-muted-foreground sm:mt-5 sm:text-xl lg:text-lg xl:text-xl">
                Stop wasting hours on repetitive paperwork. Lazily.AI generates perfect, error-free residential contracts with one click, so you can focus on closing deals.
              </p>
              <div className="mt-8 sm:max-w-lg sm:mx-auto sm:text-center lg:text-left lg:mx-0">
                <Button
                  size="lg"
                  asChild
                  className="text-lg rounded-full"
                >
                  <Link href="/sign-up">
                    Generate Your First Contract
                    <ArrowRight className="ml-2 h-5 w-5" />
                  </Link>
                </Button>
              </div>
            </div>
            <div className="mt-12 lg:mt-0 lg:col-span-6 flex justify-center">
              <Image 
                src="/sloth.png"
                alt="Lazily.AI Mascot"
                width={400}
                height={400}
                priority={true}
              />
            </div>
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section className="py-16 bg-card/50 w-full">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-12">
             <h2 className="text-3xl font-bold text-foreground">The Effortless Contract Engine</h2>
             <p className="mt-2 text-lg text-muted-foreground">Turn hours of paperwork into seconds of work.</p>
          </div>
          <div className="lg:grid lg:grid-cols-3 lg:gap-8">
            {/* Feature 1 */}
            <div>
              <div className="flex items-center justify-center h-12 w-12 rounded-md bg-primary/20 text-primary">
                <Zap className="h-6 w-6" />
              </div>
              <div className="mt-5">
                <h3 className="text-lg font-medium text-foreground">
                  Instant Generation
                </h3>
                <p className="mt-2 text-base text-muted-foreground">
                  Input your deal details and generate a complete, compliant TREC 1-4 contract in less than 30 seconds.
                </p>
              </div>
            </div>
            {/* Feature 2 */}
            <div className="mt-10 lg:mt-0">
              <div className="flex items-center justify-center h-12 w-12 rounded-md bg-primary/20 text-primary">
                <FileText className="h-6 w-6" />
              </div>
              <div className="mt-5">
                <h3 className="text-lg font-medium text-foreground">
                  Eliminate Errors
                </h3>
                <p className="mt-2 text-base text-muted-foreground">
                  Our AI ensures every field is filled correctly, every time, reducing the risk of costly mistakes and delays.
                </p>
              </div>
            </div>
            {/* Feature 3 */}
            <div className="mt-10 lg:mt-0">
              <div className="flex items-center justify-center h-12 w-12 rounded-md bg-primary/20 text-primary">
                <Workflow className="h-6 w-6" />
              </div>
              <div className="mt-5">
                <h3 className="text-lg font-medium text-foreground">
                  Bulk Automation
                </h3>
                <p className="mt-2 text-base text-muted-foreground">
                  Have a list of properties? Upload a spreadsheet and generate hundreds of contracts at once. Effortlessly done.
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Final CTA Section */}
      <section className="py-16 bg-background">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="lg:grid lg:grid-cols-2 lg:gap-8 lg:items-center">
            <div>
             <h2 className="text-3xl font-bold text-foreground sm:text-4xl">
                Ready to stop typing and start closing?
             </h2>
              <p className="mt-3 max-w-3xl text-lg text-muted-foreground">
                Get started with a low monthly fee and simple, pay-as-you-go contract generation.
              </p>
            </div>
            <div className="mt-8 lg:mt-0 flex justify-center lg:justify-end">
                <Button
                  size="lg"
                  asChild
                  className="text-lg rounded-full"
                >
                  <Link href="/pricing">
                    View Pricing
                    <ArrowRight className="ml-3 h-6 w-6" />
                  </Link>
                </Button>
            </div>
          </div>
        </div>
      </section>
    </main>
  );
}


================================================
FILE: app/(dashboard)/terminal.tsx
================================================
'use client';

import { useState, useEffect } from 'react';
import { Copy, Check } from 'lucide-react';

export function Terminal() {
  const [terminalStep, setTerminalStep] = useState(0);
  const [copied, setCopied] = useState(false);
  const terminalSteps = [
    'git clone https://github.com/nextjs/saas-starter',
    'pnpm install',
    'pnpm db:setup',
    'pnpm db:migrate',
    'pnpm db:seed',
    'pnpm dev ðŸŽ‰',
  ];

  useEffect(() => {
    const timer = setTimeout(() => {
      setTerminalStep((prev) =>
        prev < terminalSteps.length - 1 ? prev + 1 : prev
      );
    }, 500);

    return () => clearTimeout(timer);
  }, [terminalStep]);

  const copyToClipboard = () => {
    navigator.clipboard.writeText(terminalSteps.join('\n'));
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="w-full rounded-lg shadow-lg overflow-hidden bg-gray-900 text-white font-mono text-sm relative">
      <div className="p-4">
        <div className="flex justify-between items-center mb-4">
          <div className="flex space-x-2">
            <div className="w-3 h-3 rounded-full bg-red-500"></div>
            <div className="w-3 h-3 rounded-full bg-yellow-500"></div>
            <div className="w-3 h-3 rounded-full bg-green-500"></div>
          </div>
          <button
            onClick={copyToClipboard}
            className="text-gray-400 hover:text-white transition-colors"
            aria-label="Copy to clipboard"
          >
            {copied ? (
              <Check className="h-5 w-5" />
            ) : (
              <Copy className="h-5 w-5" />
            )}
          </button>
        </div>
        <div className="space-y-2">
          {terminalSteps.map((step, index) => (
            <div
              key={index}
              className={`${index > terminalStep ? 'opacity-0' : 'opacity-100'} transition-opacity duration-300`}
            >
              <span className="text-green-400">$</span> {step}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: app/(dashboard)/dashboard/layout.tsx
================================================
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Users, Settings, Shield, Activity, Menu, FileText, CreditCard } from 'lucide-react';

export default function DashboardLayout({
  children
}: {
  children: React.ReactNode;
}) {
  const pathname = usePathname();
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);

  const navItems = [
    { href: '/dashboard/contracts', icon: FileText, label: 'Contracts' },
    { href: '/dashboard/billing', icon: CreditCard, label: 'Billing' },
    { href: '/dashboard', icon: Users, label: 'Team Settings' },
    { href: '/dashboard/general', icon: Settings, label: 'General' },
    { href: '/dashboard/activity', icon: Activity, label: 'Activity' },
    { href: '/dashboard/security', icon: Shield, label: 'Security' }
  ];

  return (
    <div className="flex flex-col min-h-[calc(100dvh-68px)] max-w-7xl mx-auto w-full">
      {/* Mobile header */}
      <div className="lg:hidden flex items-center justify-between bg-card border-b border-border p-4">
        <div className="flex items-center">
          <span className="font-medium">Dashboard Menu</span>
        </div>
        <Button
          className="-mr-3"
          variant="ghost"
          onClick={() => setIsSidebarOpen(!isSidebarOpen)}
        >
          <Menu className="h-6 w-6" />
          <span className="sr-only">Toggle sidebar</span>
        </Button>
      </div>

      <div className="flex flex-1 h-full">
        {/* START: Added overlay for mobile menu */}
        {isSidebarOpen && (
          <div
            className="fixed inset-0 z-40 bg-black/50 lg:hidden"
            onClick={() => setIsSidebarOpen(false)}
          />
        )}
        {/* END: Added overlay for mobile menu */}
        
        {/* Sidebar */}
        <aside
          className={`w-64 bg-card lg:bg-background/50 border-r border-border lg:block fixed inset-y-0 left-0 z-100 transform transition-transform duration-300 ease-in-out lg:relative lg:translate-x-0 ${
            isSidebarOpen ? 'translate-x-0' : '-translate-x-full'
          }`}
        >
          <nav className="h-full overflow-y-auto p-4">
            {navItems.map((item) => (
              <Link key={item.href} href={item.href} passHref>
                <Button
                  variant={pathname === item.href ? 'secondary' : 'ghost'}
                  className="shadow-none my-1 w-full justify-start gap-2"
                  onClick={() => setIsSidebarOpen(false)} // Close menu on link click
                >
                  <item.icon className="h-4 w-4" />
                  {item.label}
                </Button>
              </Link>
            ))}
          </nav>
        </aside>

        {/* Main content */}
        <div className="flex-1 lg:pl-64"> {/* Added padding to prevent content from going under the sidebar on desktop */}
            <main className="p-4 lg:p-8">
                {children}
            </main>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: app/(dashboard)/dashboard/page.tsx
================================================
'use client';

import { Button } from '@/components/ui/button';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardFooter
} from '@/components/ui/card';
import { customerPortalAction } from '@/lib/payments/actions';
import { useActionState } from 'react';
import { TeamDataWithMembers, User } from '@/lib/db/schema';
import { removeTeamMember, inviteTeamMember } from '@/app/(login)/actions';
import useSWR from 'swr';
import { Suspense } from 'react';
import { Input } from '@/components/ui/input';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Loader2, PlusCircle } from 'lucide-react';

type ActionState = {
  error?: string;
  success?: string;
};

const fetcher = (url: string) => fetch(url).then((res) => res.json());

function SubscriptionSkeleton() {
  return (
    <Card className="mb-8 h-[140px]">
      <CardHeader>
        <CardTitle>Team Subscription</CardTitle>
      </CardHeader>
    </Card>
  );
}

function ManageSubscription() {
  const { data: teamData } = useSWR<TeamDataWithMembers>('/api/team', fetcher);

  return (
    <Card className="mb-8">
      <CardHeader>
        <CardTitle>Team Subscription</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center">
            <div className="mb-4 sm:mb-0">
              <p className="font-medium">
                Current Plan: {teamData?.planName || 'Free'}
              </p>
              <p className="text-sm text-muted-foreground">
                {teamData?.subscriptionStatus === 'active'
                  ? 'Billed monthly'
                  : teamData?.subscriptionStatus === 'trialing'
                  ? 'Trial period'
                  : 'No active subscription'}
              </p>
            </div>
            <form action={customerPortalAction}>
              <Button type="submit" variant="outline">
                Manage Subscription
              </Button>
            </form>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

function TeamMembersSkeleton() {
  return (
    <Card className="mb-8 h-[140px]">
      <CardHeader>
        <CardTitle>Team Members</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="animate-pulse space-y-4 mt-1">
          <div className="flex items-center space-x-4">
            <div className="size-8 rounded-full bg-gray-200"></div>
            <div className="space-y-2">
              <div className="h-4 w-32 bg-gray-200 rounded"></div>
              <div className="h-3 w-14 bg-gray-200 rounded"></div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

function TeamMembers() {
  const { data: teamData } = useSWR<TeamDataWithMembers>('/api/team', fetcher);
  const [removeState, removeAction, isRemovePending] = useActionState<
    ActionState,
    FormData
  >(removeTeamMember, {});

  const getUserDisplayName = (user: Pick<User, 'id' | 'name' | 'email'>) => {
    return user.name || user.email || 'Unknown User';
  };

  if (!teamData?.teamMembers?.length) {
    return (
      <Card className="mb-8">
        <CardHeader>
          <CardTitle>Team Members</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground">No team members yet.</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="mb-8">
      <CardHeader>
        <CardTitle>Team Members</CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="space-y-4">
          {teamData.teamMembers.map((member, index) => (
            <li key={member.id} className="flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <Avatar>
                  {/* 
                    This app doesn't save profile images, but here
                    is how you'd show them:

                    <AvatarImage
                      src={member.user.image || ''}
                      alt={getUserDisplayName(member.user)}
                    />
                  */}
                  <AvatarFallback>
                    {getUserDisplayName(member.user)
                      .split(' ')
                      .map((n) => n[0])
                      .join('')}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <p className="font-medium">
                    {getUserDisplayName(member.user)}
                  </p>
                  <p className="text-sm text-muted-foreground capitalize">
                    {member.role}
                  </p>
                </div>
              </div>
              {index > 1 ? (
                <form action={removeAction}>
                  <input type="hidden" name="memberId" value={member.id} />
                  <Button
                    type="submit"
                    variant="outline"
                    size="sm"
                    disabled={isRemovePending}
                  >
                    {isRemovePending ? 'Removing...' : 'Remove'}
                  </Button>
                </form>
              ) : null}
            </li>
          ))}
        </ul>
        {removeState?.error && (
          <p className="text-red-500 mt-4">{removeState.error}</p>
        )}
      </CardContent>
    </Card>
  );
}

function InviteTeamMemberSkeleton() {
  return (
    <Card className="h-[260px]">
      <CardHeader>
        <CardTitle>Invite Team Member</CardTitle>
      </CardHeader>
    </Card>
  );
}

function InviteTeamMember() {
  const { data: user } = useSWR<User>('/api/user', fetcher);
  const isOwner = user?.role === 'owner';
  const [inviteState, inviteAction, isInvitePending] = useActionState<
    ActionState,
    FormData
  >(inviteTeamMember, {});

  return (
    <Card>
      <CardHeader>
        <CardTitle>Invite Team Member</CardTitle>
      </CardHeader>
      <CardContent>
        <form action={inviteAction} className="space-y-4">
          <div>
            <Label htmlFor="email" className="mb-2">
              Email
            </Label>
            <Input
              id="email"
              name="email"
              type="email"
              placeholder="Enter email"
              required
              disabled={!isOwner}
            />
          </div>
          <div>
            <Label>Role</Label>
            <RadioGroup
              defaultValue="member"
              name="role"
              className="flex space-x-4"
              disabled={!isOwner}
            >
              <div className="flex items-center space-x-2 mt-2">
                <RadioGroupItem value="member" id="member" />
                <Label htmlFor="member">Member</Label>
              </div>
              <div className="flex items-center space-x-2 mt-2">
                <RadioGroupItem value="owner" id="owner" />
                <Label htmlFor="owner">Owner</Label>
              </div>
            </RadioGroup>
          </div>
          {inviteState?.error && (
            <p className="text-red-500">{inviteState.error}</p>
          )}
          {inviteState?.success && (
            <p className="text-green-500">{inviteState.success}</p>
          )}
          <Button
            type="submit"
            className="bg-orange-500 hover:bg-orange-600 text-white"
            disabled={isInvitePending || !isOwner}
          >
            {isInvitePending ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Inviting...
              </>
            ) : (
              <>
                <PlusCircle className="mr-2 h-4 w-4" />
                Invite Member
              </>
            )}
          </Button>
        </form>
      </CardContent>
      {!isOwner && (
        <CardFooter>
          <p className="text-sm text-muted-foreground">
            You must be a team owner to invite new members.
          </p>
        </CardFooter>
      )}
    </Card>
  );
}

export default function SettingsPage() {
  return (
    <section className="flex-1 p-4 lg:p-8">
      <h1 className="text-lg lg:text-2xl font-medium mb-6">Team Settings</h1>
      <Suspense fallback={<SubscriptionSkeleton />}>
        <ManageSubscription />
      </Suspense>
      <Suspense fallback={<TeamMembersSkeleton />}>
        <TeamMembers />
      </Suspense>
      <Suspense fallback={<InviteTeamMemberSkeleton />}>
        <InviteTeamMember />
      </Suspense>
    </section>
  );
}



================================================
FILE: app/(dashboard)/dashboard/activity/loading.tsx
================================================
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export default function ActivityPageSkeleton() {
  return (
    <section className="flex-1 p-4 lg:p-8">
      <h1 className="text-lg lg:text-2xl font-medium text-gray-900 mb-6">
        Activity Log
      </h1>
      <Card>
        <CardHeader>
          <CardTitle>Recent Activity</CardTitle>
        </CardHeader>
        <CardContent className="min-h-[88px]" />
      </Card>
    </section>
  );
}



================================================
FILE: app/(dashboard)/dashboard/activity/page.tsx
================================================
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Settings,
  LogOut,
  UserPlus,
  Lock,
  UserCog,
  AlertCircle,
  UserMinus,
  Mail,
  CheckCircle,
  type LucideIcon,
  CreditCard,
  Repeat,
  FileText,
  ShoppingCart,
} from 'lucide-react';
import { ActivityType } from '@/lib/db/schema';
import { getActivityLogs } from '@/lib/db/queries';

const iconMap: Record<ActivityType, LucideIcon> = {
  [ActivityType.SIGN_UP]: UserPlus,
  [ActivityType.SIGN_IN]: UserCog,
  [ActivityType.SIGN_OUT]: LogOut,
  [ActivityType.UPDATE_PASSWORD]: Lock,
  [ActivityType.DELETE_ACCOUNT]: UserMinus,
  [ActivityType.UPDATE_ACCOUNT]: Settings,
  [ActivityType.CREATE_TEAM]: UserPlus,
  [ActivityType.REMOVE_TEAM_MEMBER]: UserMinus,
  [ActivityType.INVITE_TEAM_MEMBER]: Mail,
  [ActivityType.ACCEPT_INVITATION]: CheckCircle,
  [ActivityType.MEMBERSHIP_PURCHASE]: ShoppingCart,
  [ActivityType.MEMBERSHIP_RENEWAL]: Repeat,
  [ActivityType.CREDIT_PURCHASE]: CreditCard,
  [ActivityType.CONTRACT_GENERATED]: FileText,
};

function getRelativeTime(date: Date) {
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (diffInSeconds < 60) return 'just now';
  if (diffInSeconds < 3600)
    return `${Math.floor(diffInSeconds / 60)} minutes ago`;
  if (diffInSeconds < 86400)
    return `${Math.floor(diffInSeconds / 3600)} hours ago`;
  if (diffInSeconds < 604800)
    return `${Math.floor(diffInSeconds / 86400)} days ago`;
  return date.toLocaleDateString();
}

function formatAction(action: ActivityType): string {
  switch (action) {
    case ActivityType.SIGN_UP:
      return 'You signed up';
    case ActivityType.SIGN_IN:
      return 'You signed in';
    case ActivityType.SIGN_OUT:
      return 'You signed out';
    case ActivityType.UPDATE_PASSWORD:
      return 'You changed your password';
    case ActivityType.DELETE_ACCOUNT:
      return 'You deleted your account';
    case ActivityType.UPDATE_ACCOUNT:
      return 'You updated your account';
    case ActivityType.CREATE_TEAM:
      return 'You created a new team';
    case ActivityType.REMOVE_TEAM_MEMBER:
      return 'You removed a team member';
    case ActivityType.INVITE_TEAM_MEMBER:
      return 'You invited a team member';
    case ActivityType.ACCEPT_INVITATION:
      return 'You accepted an invitation';
    case ActivityType.MEMBERSHIP_PURCHASE:
      return 'You purchased a membership';
    case ActivityType.MEMBERSHIP_RENEWAL:
      return 'Your membership was renewed';
    case ActivityType.CREDIT_PURCHASE:
      return 'You purchased credits';
    case ActivityType.CONTRACT_GENERATED:
      return 'You generated a contract';
    default:
      return 'Unknown action occurred';
  }
}

export default async function ActivityPage() {
  const logs = await getActivityLogs();

  return (
    <section className="flex-1 p-4 lg:p-8">
      <h1 className="text-lg lg:text-2xl font-medium text-gray-900 mb-6">
        Activity Log
      </h1>
      <Card>
        <CardHeader>
          <CardTitle>Recent Activity</CardTitle>
        </CardHeader>
        <CardContent>
          {logs.length > 0 ? (
            <ul className="space-y-4">
              {logs.map((log) => {
                const Icon = iconMap[log.action as ActivityType] || Settings;
                const formattedAction = formatAction(
                  log.action as ActivityType
                );

                return (
                  <li key={log.id} className="flex items-center space-x-4">
                    <div className="bg-orange-100 rounded-full p-2">
                      <Icon className="w-5 h-5 text-orange-600" />
                    </div>
                    <div className="flex-1">
                      <p className="text-sm font-medium text-gray-900">
                        {formattedAction}
                        {log.ipAddress && ` from IP ${log.ipAddress}`}
                      </p>
                      <p className="text-xs text-gray-500">
                        {getRelativeTime(new Date(log.timestamp))}
                      </p>
                    </div>
                  </li>
                );
              })}
            </ul>
          ) : (
            <div className="flex flex-col items-center justify-center text-center py-12">
              <AlertCircle className="h-12 w-12 text-orange-500 mb-4" />
              <h3 className="text-lg font-semibold text-gray-900 mb-2">
                No activity yet
              </h3>
              <p className="text-sm text-gray-500 max-w-sm">
                When you perform actions like signing in or updating your
                account, they'll appear here.
              </p>
            </div>
          )}
        </CardContent>
      </Card>
    </section>
  );
}



================================================
FILE: app/(dashboard)/dashboard/billing/page.tsx
================================================
'use client';

export const dynamic = 'force-dynamic';

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { customerPortalAction, creditCheckoutAction } from '@/lib/payments/actions';
import useSWR, { useSWRConfig } from 'swr';
import { TeamDataWithMembers } from '@/lib/db/schema';
import { Suspense, useEffect } from "react";
import { useFormStatus } from 'react-dom';
import { CreditsCounter } from "@/components/dashboard/CreditsCounter";
import { useSearchParams } from "next/navigation";

const fetcher = (url: string) => fetch(url).then((res) => res.json());

function ManageSubscription() {
  const { data: teamData } = useSWR<TeamDataWithMembers>('/api/team', fetcher);
  return (
    <Card>
      <CardHeader>
        <CardTitle>Your Subscription</CardTitle>
        <CardDescription>
          Your $10/month subscription gives you access to the Lazily.AI platform and all its features.
        </CardDescription>
      </CardHeader>
      <CardContent>
          <div className="flex justify-between items-center">
            <div>
              <p className="font-medium text-lg">
                $10 / month
              </p>
              <p className="text-sm text-muted-foreground capitalize">
                Status: {teamData?.subscriptionStatus || '...'}
              </p>
            </div>
            <form action={customerPortalAction}>
              <Button type="submit" variant="outline">
                Manage Subscription
              </Button>
            </form>
          </div>
      </CardContent>
    </Card>
  );
}

function PurchaseButton({ price }: { price: number }) {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" className="w-full" disabled={pending}>
      {pending ? "Processing..." : `Purchase for $${price}`}
    </Button>
  );
}

function CreditPack({ credits, price, discount, priceId }: { credits: number; price: number; discount: string; priceId: string }) {
  return (
    <Card className="flex flex-col">
      <CardHeader>
        <CardTitle>{credits} Credits</CardTitle>
        <CardDescription>{discount}</CardDescription>
      </CardHeader>
      <CardContent className="flex-grow flex items-end">
        <form action={creditCheckoutAction} className="w-full">
          <input type="hidden" name="priceId" value={priceId} />
          <PurchaseButton price={price} />
        </form>
      </CardContent>
    </Card>
  );
}

function Billing() {
  const { mutate } = useSWRConfig();
  const searchParams = useSearchParams();
  const success = searchParams.get('success');

  useEffect(() => {
    if (success === 'true') {
      mutate('/api/team/credits');
    }
  }, [success, mutate]);

  return (
    <section>
      <h1 className="text-lg lg:text-2xl font-medium mb-6">
        Subscription & Billing
      </h1>

      <div className="space-y-8">
        <div className="grid gap-4 md:grid-cols-4">
            <div className="md:col-span-1">
                <CreditsCounter />
            </div>
        </div>

        <Suspense fallback={<Card className="h-32 animate-pulse" />}>
          <ManageSubscription />
        </Suspense>

        <Card>
          <CardHeader>
            <CardTitle>Purchase Contract Credits</CardTitle>
            <CardDescription>
              One credit is used for each TREC 1-4 form you generate. For example, uploading a CSV with 20 rows will require 20 credits.
            </CardDescription>
          </CardHeader>
          <CardContent className="grid md:grid-cols-3 gap-6">
            <CreditPack credits={20} price={90} discount="10% Discount" priceId="price_1Ro7OYPnNiwcL8wH91lgBFm1" />
            <CreditPack credits={50} price={185} discount="25% Discount" priceId="price_1Ro7a1PnNiwcL8wH0Ok54dwB" />
            <CreditPack credits={100} price={335} discount="33% Discount" priceId="price_1Ro7aKPnNiwcL8wHErefGhbq" />
          </CardContent>
        </Card>
      </div>
    </section>
  );
}

export default function BillingPage() {
  return (
    <Suspense fallback={<div className="w-full h-full flex items-center justify-center"><p>Loading...</p></div>}>
      <Billing />
    </Suspense>
  );
}


================================================
FILE: app/(dashboard)/dashboard/contracts/actions.ts
================================================
// app/(dashboard)/dashboard/contracts/actions.ts

'use server';

import { db } from '@/lib/db/drizzle';
import { contracts, ActivityType } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
import { getUser, createActivityLog, getTeamForUser } from '@/lib/db/queries';
import { PDFDocument } from 'pdf-lib';
import fs from 'fs/promises';
import path from 'path';
import { Trec14ContractData } from '@/lib/contracts/validation';

export async function generateContractAction(contractId: number): Promise<Uint8Array> {
  const user = await getUser();
  if (!user) throw new Error('Not authenticated');

  const contract = await db.query.contracts.findFirst({ where: eq(contracts.id, contractId) });
  if (!contract) throw new Error('Contract not found.');

  const team = await getTeamForUser();
  if (team) {
    await createActivityLog({
      teamId: team.id,
      userId: user.id,
      action: ActivityType.CONTRACT_GENERATED,
    });
  }
  
  const data = contract.contractData as Trec14ContractData;

  const templatePath = path.join(process.cwd(), 'lib/templates/TREC-20-18-automated-v1.pdf');
  const pdfTemplateBytes = await fs.readFile(templatePath);
  const pdfDoc = await PDFDocument.load(pdfTemplateBytes);
  const form = pdfDoc.getForm();

  const fillText = (fieldName: string, value: string | null | undefined) => {
    try {
      if (value !== null && value !== undefined) form.getTextField(fieldName).setText(value);
    } catch (e) { console.log(`Could not find TextField: ${fieldName}`); }
  };

  const check = (fieldName: string, value: boolean | null | undefined) => {
    try {
      if (value) form.getCheckBox(fieldName).check();
    } catch (e) { console.log(`Could not find CheckBox: ${fieldName}`); }
  };

  // --- Parties ---
  fillText('parties.seller', data.parties?.seller);
  fillText('parties.buyer', data.parties?.buyer);

  // --- Property ---
  fillText('property.lot', data.property?.lot);
  fillText('property.block', data.property?.block);
  fillText('property.addition', data.property?.addition);
  fillText('property.city', data.property?.city);
  fillText('property.county', data.property?.county);
  fillText('property.address', data.property?.address);
  fillText('property.exclusions.part1', data.property?.exclusions?.part1);
  fillText('property.exclusions.part2', data.property?.exclusions?.part2);
  
  const hoaStatus = data.property?.hoaStatus;
  if (hoaStatus === 'is_subject') check('property.hoaStatus.is_subject', true);
  else if (hoaStatus === 'not_subject') check('property.hoaStatus.not_subject', true);

  // --- Price ---
  fillText('price.cashPortion', data.price?.cashPortion);
  fillText('price.financeAmount', data.price?.financeAmount);
  fillText('price.salesPrice', data.price?.salesPrice);

  // --- Financing ---
  check('financing.thirdParty', data.financing?.thirdParty);
  check('financing.loanAssumption', data.financing?.loanAssumption);
  check('financing.seller', data.financing?.seller);

  // --- Leases ---
  check('leases.isResidential', data.leases?.isResidential);
  check('leases.isFixture', data.leases?.isFixture);
  check('leases.isNaturalResource', data.leases?.isNaturalResource);

  // --- Earnest Money ---
  fillText('earnestMoney.escrowAgentName', data.earnestMoney?.escrowAgentName);
  fillText('earnestMoney.escrowAgentAddress.part1', data.earnestMoney?.escrowAgentAddress?.part1);
  fillText('earnestMoney.amount', data.earnestMoney?.amount);
  fillText('earnestMoney.additionalAmount', data.earnestMoney?.additionalAmount);
  fillText('earnestMoney.additionalAmountDays', data.earnestMoney?.additionalAmountDays);

  // --- Option Fee ---
  fillText('optionFee.amount', data.optionFee?.amount);
  fillText('optionFee.days', data.optionFee?.days);

  // --- Title Policy ---
  fillText('titlePolicy.companyName', data.titlePolicy?.companyName);
  const titlePayer = data.titlePolicy?.payer;
  if (titlePayer === 'Seller') check('titlePolicy.payer.seller', true);
  else if (titlePayer === 'Buyer') check('titlePolicy.payer.buyer', true);

  const shortageStatus = data.titlePolicy?.shortageAmendment?.status;
  if (shortageStatus === 'shall_be_amended') check('titlePolicy.shortageAmendment.status.shall_be_amended', true);
  else if (shortageStatus === 'will_not_be_amended') check('titlePolicy.shortageAmendment.status.will_not_be_amended', true);

  const shortagePayer = data.titlePolicy?.shortageAmendment?.payer;
  if (shortagePayer === 'Seller') check('titlePolicy.shortageAmendment.payer.seller', true);
  else if (shortagePayer === 'Buyer') check('titlePolicy.shortageAmendment.payer.buyer', true);

  // --- Survey ---
  const surveyStatus = data.survey?.status;
  if (surveyStatus === "existing_survey_provided") check("survey.status.existing_survey_provided", true);
  else if (surveyStatus === "new_survey_ordered") check("survey.status.new_survey_ordered", true);
  else if (surveyStatus === "new_survey_by_seller") check("survey.status.new_survey_by_seller", true);

  fillText('survey.existing.deliveryDays', data.survey?.existing?.deliveryDays);
  const affidavitPayer = data.survey?.existing?.affidavitPayer;
  if (affidavitPayer === 'seller') check('survey.existing.affidavitPayer.seller', true);
  else if (affidavitPayer === 'buyer') check('survey.existing.affidavitPayer.buyer', true);

  // --- Objections ---
  fillText('objections.objectionDays', data.objections?.objectionDays);

  // --- Property Condition ---
  const disclosureStatus = data.propertyCondition?.sellerDisclosure?.status;
  if (disclosureStatus === 'received') check('propertyCondition.sellerDisclosure.status.received', true);
  else if (disclosureStatus === 'not_received') check('propertyCondition.sellerDisclosure.status.not_received', true);
  else if (disclosureStatus === 'not_required') check('propertyCondition.sellerDisclosure.status.not_required', true);
  
  fillText('propertyCondition.sellerDisclosure.deliveryDays', data.propertyCondition?.sellerDisclosure?.deliveryDays);

  const acceptanceStatus = data.propertyCondition?.acceptanceStatus;
  if (acceptanceStatus === 'as_is') check('propertyCondition.acceptanceStatus.as_is', true);
  else if (acceptanceStatus === 'as_is_with_repairs') check('propertyCondition.acceptanceStatus.as_is_with_repairs', true);

  fillText('propertyCondition.repairsList.part1', data.propertyCondition?.repairsList?.part1);

  // --- Brokers ---
  fillText('brokers.listing.associate.name', data.brokers?.listing?.associate?.name);
  fillText('brokers.listing.associate.licenseNo', data.brokers?.listing?.associate?.licenseNo);
  fillText('brokers.listing.firmName', data.brokers?.listing?.firmName);
  fillText('brokers.listing.firmLicenseNo', data.brokers?.listing?.firmLicenseNo);
  fillText('brokers.other.associate.name', data.brokers?.other?.associate?.name);
  fillText('brokers.other.associate.licenseNo', data.brokers?.other?.associate?.licenseNo);
  fillText('brokers.other.firmName', data.brokers?.other?.firmName);
  fillText('brokers.other.firmLicenseNo', data.brokers?.other?.firmLicenseNo);

  const listingRepresents = data.brokers?.listing?.represents;
  if (listingRepresents === 'seller_agent') check('brokers.listing.represents.seller_agent', true);
  else if (listingRepresents === 'intermediary') check('brokers.listing.represents.intermediary', true);

  const otherRepresents = data.brokers?.other?.represents;
  if (otherRepresents === 'buyer_agent') check('brokers.other.represents.buyer_agent', true);
  else if (otherRepresents === 'seller_subagent') check('brokers.other.represents.seller_subagent', true);

  // --- Closing ---
  fillText('closing.date.monthDay', data.closing?.date?.monthDay);
  fillText('closing.date.year', data.closing?.date?.year);

  // --- Possession ---
  const possessionStatus = data.possession?.status;
  if (possessionStatus === 'upon_closing') check('possession.status.upon_closing', true);
  else if (possessionStatus === 'temporary_lease') check('possession.status.temporary_lease', true);

  // --- Special Provisions ---
  fillText('specialProvisions.text', data.specialProvisions?.text);

  // --- Settlement ---
  fillText('settlement.sellerContributionToOther.amount', data.settlement?.sellerContributionToOther?.amount);

  // --- Notices ---
  fillText('notices.buyer.contactInfo.part1', data.notices?.buyer?.contactInfo?.part1);
  fillText('notices.seller.contactInfo.part1', data.notices?.seller?.contactInfo?.part1);

  // --- Addenda ---
  check('addenda.thirdPartyFinancing', data.addenda?.thirdPartyFinancing);
  check('addenda.sellerFinancing', data.addenda?.sellerFinancing);
  check('addenda.hoa', data.addenda?.hoa);
  check('addenda.buyersTemporaryLease', data.addenda?.buyersTemporaryLease);
  check('addenda.loanAssumption', data.addenda?.loanAssumption);
  check('addenda.saleOfOtherProperty', data.addenda?.saleOfOtherProperty);
  check('addenda.leadBasedPaint', data.addenda?.leadBasedPaint);
  check('addenda.sellersTemporaryLease', data.addenda?.sellersTemporaryLease);
  fillText('addenda.otherText.p1', data.addenda?.otherText?.p1);

  // --- Attorneys ---
  fillText('attorneys.buyer.name', data.attorneys?.buyer?.name);
  fillText('attorneys.buyer.phone', data.attorneys?.buyer?.phone);
  fillText('attorneys.buyer.email', data.attorneys?.buyer?.email);
  fillText('attorneys.seller.name', data.attorneys?.seller?.name);
  fillText('attorneys.seller.phone', data.attorneys?.seller?.phone);
  fillText('attorneys.seller.email', data.attorneys?.seller?.email);

  // --- Execution ---
  fillText('execution.day', data.execution?.day);
  fillText('execution.month', data.execution?.month);
  fillText('execution.year', data.execution?.year);

  form.flatten();
  return await pdfDoc.save();
}


================================================
FILE: app/(dashboard)/dashboard/contracts/agents.md
================================================
# Lazily.AI: Dashboard Contracts Agent Guide

This `AGENTS.md` provides specific guidance for working within the `app/(dashboard)/dashboard/contracts` directory.

## 1. Core Responsibility

This module is the user's primary workspace for **uploading CSVs to generate contracts and downloading the resulting TREC 1-4 PDF files**. It integrates the front-end user experience with the core backend contract generation logic.

## 2. Key Files & Directives

*   **`actions.ts` (specifically `generateContractAction`)**:
    *   This server action is responsible for **filling the TREC 1-4 PDF template using `pdf-lib`** [46, 49, 50].
    *   **Ensure every field defined in `Trec14Schema` is mapped and filled** within this action, using `fillText` for text fields and `check` for checkboxes [50-65]. Refer to `lib/contracts/validation.ts` for the data structure and `inspect-pdf.mjs` for PDF field names [19, 66-68].
    *   After filling, **always call `form.flatten()`** to make the PDF non-editable and ensure consistent appearance across viewers [44, 69].
    *   Ensure **activity logging** for `CONTRACT_GENERATED` is correctly implemented for each generation [67, 70].

*   **`page.tsx`**:
    *   This page orchestrates the display of `CsvUploadForm` and `ContractList` [44, 45].
    *   Ensure `CreditsCounter` and `CreditRefresher` components are properly integrated to provide up-to-date credit balance information [45, 71, 72].

*   **`components/dashboard/DownloadContractButton.tsx`**:
    *   This client component triggers the `generateContractAction` on the server [73].
    *   It handles the client-side download of the generated PDF bytes received from the server action [74].

## 3. Development Workflow

*   When updating the PDF template (`lib/templates/TREC-20-18-automated-v1.pdf`), **verify that all field names used in `generateContractAction` still match** the new template [75]. If field names change, update the `actions.ts` accordingly.
*   The `processCsvFile` action (located in `app/(login)/actions.ts`) is responsible for saving the raw contract data and deducting credits [7, 14, 27, 76, 77]. This directory's `actions.ts` focuses only on generating the PDF from *already saved* data.



================================================
FILE: app/(dashboard)/dashboard/contracts/page.tsx
================================================
import { CsvUploadForm } from '@/components/dashboard/CsvUploadForm';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { CreditsCounter } from "@/components/dashboard/CreditsCounter";
import { ContractList } from '@/components/dashboard/ContractList';
import { CreditRefresher } from '@/components/dashboard/CreditRefresher';
import { Suspense } from 'react';

export default async function ContractsPage() {
  return (
    <section className="space-y-6">
      <Suspense fallback={null}>
        <CreditRefresher />
      </Suspense>
      <div className="grid gap-4 md:grid-cols-4">
        <CreditsCounter />
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Upload Your Property List</CardTitle>
          <CardDescription>
            Upload a CSV file with your property and owner data. A TREC 1-4 form will be generated for each row.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <CsvUploadForm />
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Generated Contracts</CardTitle>
          <CardDescription>
            Contracts you've created from a CSV upload will appear here.
          </CardDescription>
        </CardHeader>
        <CardContent className="p-0">
          <ContractList />
        </CardContent>
      </Card>
    </section>
  );
}


================================================
FILE: app/(dashboard)/dashboard/general/page.tsx
================================================
'use client';

import { useActionState, Suspense } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { Loader2 } from 'lucide-react';
import { updateAccount } from '@/app/(login)/actions';
import { User } from '@/lib/db/schema';
import useSWR from 'swr';

const fetcher = (url: string) => fetch(url).then((res) => res.json());

type ActionState = {
  name?: string;
  error?: string;
  success?: string;
};

function AccountForm({ user }: { user: User | undefined }) {
  return (
    <div className="space-y-4">
      <div className="grid md:grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="name">Name</Label>
          <Input id="name" name="name" placeholder="Enter your name" defaultValue={user?.name ?? ''} required />
        </div>
        <div className="space-y-2">
          <Label htmlFor="email">Email</Label>
          <Input id="email" name="email" type="email" placeholder="Enter your email" defaultValue={user?.email ?? ''} disabled />
          <p className="text-xs text-muted-foreground">Email address cannot be changed.</p>
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="phone">Phone Number (Optional)</Label>
        <Input id="phone" name="phone" type="tel" placeholder="Enter your phone number" defaultValue={user?.phone ?? ''} />
      </div>
      
      <div className="space-y-4 pt-4">
        <Label className="font-medium">Marketing Preferences</Label>
        <div className="flex items-start space-x-3">
          {/* THE FIX IS HERE */}
          <Checkbox id="marketingEmailConsent" name="marketingEmailConsent" defaultChecked={user?.marketingEmailConsent || false} />
          <div className="grid gap-1.5 leading-none">
            <label htmlFor="marketingEmailConsent" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
              Receive emails from Lazily.AI
            </label>
            <p className="text-sm text-muted-foreground">
              Get notified about new features, special offers, and tips.
            </p>
          </div>
        </div>
        <div className="flex items-start space-x-3">
          {/* AND THE FIX IS HERE */}
          <Checkbox id="marketingSmsConsent" name="marketingSmsConsent" defaultChecked={user?.marketingSmsConsent || false}/>
          <div className="grid gap-1.5 leading-none">
            <label htmlFor="marketingSmsConsent" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
              Receive text messages (SMS) from Lazily.AI
            </label>
            <p className="text-sm text-muted-foreground">
              Get occasional updates and alerts. Message and data rates may apply.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}

export default function GeneralPage() {
  const [state, formAction, isPending] = useActionState<ActionState, FormData>(updateAccount, {});
  const { data: user } = useSWR<User>('/api/user', fetcher);

  return (
    <section>
      <h1 className="text-lg lg:text-2xl font-medium mb-6">
        General Settings
      </h1>

      <form action={formAction}>
        <Card>
          <CardHeader>
            <CardTitle>Account Information</CardTitle>
            <CardDescription>
              Update your account details and marketing preferences.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Suspense fallback={<div className="h-48 animate-pulse rounded-md bg-card" />}>
              <AccountForm user={user} />
            </Suspense>
          </CardContent>
          <CardFooter className="border-t px-6 py-4 flex justify-between items-center">
            <div className="text-sm">
              {state.error && <p className="text-destructive">{state.error}</p>}
              {state.success && <p className="text-green-600">{state.success}</p>}
            </div>
            <Button type="submit" disabled={isPending}>
              {isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Saving...
                </>
              ) : (
                'Save Changes'
              )}
            </Button>
          </CardFooter>
        </Card>
      </form>
    </section>
  );
}


================================================
FILE: app/(dashboard)/dashboard/security/page.tsx
================================================
'use client';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Lock, Trash2, Loader2 } from 'lucide-react';
import { useActionState } from 'react';
import { updatePassword, deleteAccount } from '@/app/(login)/actions';

type PasswordState = {
  currentPassword?: string;
  newPassword?: string;
  confirmPassword?: string;
  error?: string;
  success?: string;
};

type DeleteState = {
  password?: string;
  error?: string;
  success?: string;
};

export default function SecurityPage() {
  const [passwordState, passwordAction, isPasswordPending] = useActionState<
    PasswordState,
    FormData
  >(updatePassword, {});

  const [deleteState, deleteAction, isDeletePending] = useActionState<
    DeleteState,
    FormData
  >(deleteAccount, {});

  return (
    <section className="flex-1 p-4 lg:p-8">
      <h1 className="text-lg lg:text-2xl font-medium bold text-gray-900 mb-6">
        Security Settings
      </h1>
      <Card className="mb-8">
        <CardHeader>
          <CardTitle>Password</CardTitle>
        </CardHeader>
        <CardContent>
          <form className="space-y-4" action={passwordAction}>
            <div>
              <Label htmlFor="current-password" className="mb-2">
                Current Password
              </Label>
              <Input
                id="current-password"
                name="currentPassword"
                type="password"
                autoComplete="current-password"
                required
                minLength={8}
                maxLength={100}
                defaultValue={passwordState.currentPassword}
              />
            </div>
            <div>
              <Label htmlFor="new-password" className="mb-2">
                New Password
              </Label>
              <Input
                id="new-password"
                name="newPassword"
                type="password"
                autoComplete="new-password"
                required
                minLength={8}
                maxLength={100}
                defaultValue={passwordState.newPassword}
              />
            </div>
            <div>
              <Label htmlFor="confirm-password" className="mb-2">
                Confirm New Password
              </Label>
              <Input
                id="confirm-password"
                name="confirmPassword"
                type="password"
                required
                minLength={8}
                maxLength={100}
                defaultValue={passwordState.confirmPassword}
              />
            </div>
            {passwordState.error && (
              <p className="text-red-500 text-sm">{passwordState.error}</p>
            )}
            {passwordState.success && (
              <p className="text-green-500 text-sm">{passwordState.success}</p>
            )}
            <Button
              type="submit"
              className="bg-orange-500 hover:bg-orange-600 text-white"
              disabled={isPasswordPending}
            >
              {isPasswordPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Updating...
                </>
              ) : (
                <>
                  <Lock className="mr-2 h-4 w-4" />
                  Update Password
                </>
              )}
            </Button>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Delete Account</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-500 mb-4">
            Account deletion is non-reversable. Please proceed with caution.
          </p>
          <form action={deleteAction} className="space-y-4">
            <div>
              <Label htmlFor="delete-password" className="mb-2">
                Confirm Password
              </Label>
              <Input
                id="delete-password"
                name="password"
                type="password"
                required
                minLength={8}
                maxLength={100}
                defaultValue={deleteState.password}
              />
            </div>
            {deleteState.error && (
              <p className="text-red-500 text-sm">{deleteState.error}</p>
            )}
            <Button
              type="submit"
              variant="destructive"
              className="bg-red-600 hover:bg-red-700"
              disabled={isDeletePending}
            >
              {isDeletePending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Deleting...
                </>
              ) : (
                <>
                  <Trash2 className="mr-2 h-4 w-4" />
                  Delete Account
                </>
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
    </section>
  );
}



================================================
FILE: app/(dashboard)/pricing/page.tsx
================================================
import { checkoutAction } from '@/lib/payments/actions';
import { Check } from 'lucide-react';
import { getStripeProducts } from '@/lib/payments/stripe';
import { SubmitButton } from './submit-button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import Link from 'next/link';

// Prices are fresh for one hour max
export const revalidate = 3600;

export default async function PricingPage() {
    // This now uses your real Price ID for the $10/month subscription
    const platformAccessPriceId = 'price_1Ro7K7PnNiwcL8wHamerpDyu';

    return (
        <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
            <div className="text-center mb-12">
                <h1 className="text-4xl font-bold text-foreground">Simple, Transparent Pricing</h1>
                <p className="mt-2 text-lg text-muted-foreground">One simple plan to automate everything.</p>
            </div>

            <Card className="max-w-md mx-auto">
                <CardHeader className="text-center">
                    <CardTitle className="text-2xl">Lazily.AI Plan</CardTitle>
                    <CardDescription>Pay only for what you use.</CardDescription>
                </CardHeader>
                <CardContent>
                    <div className="text-center">
                        <p className="text-4xl font-medium">
                            $10 <span className="text-xl font-normal text-muted-foreground">/ month</span>
                        </p>
                        <p className="text-2xl font-medium mt-2">
                            + $5 <span className="text-xl font-normal text-muted-foreground">/ contract</span>
                        </p>
                    </div>

                    <ul className="space-y-4 my-8">
                        <li className="flex items-start">
                            <Check className="h-5 w-5 text-primary mr-2 mt-0.5 flex-shrink-0" />
                            <span className="text-foreground">AI-Powered TREC 1-4 Form Automation</span>
                        </li>
                        <li className="flex items-start">
                            <Check className="h-5 w-5 text-primary mr-2 mt-0.5 flex-shrink-0" />
                            <span className="text-foreground">Bulk Contract Generation</span>
                        </li>
                        <li className="flex items-start">
                            <Check className="h-5 w-5 text-primary mr-2 mt-0.5 flex-shrink-0" />
                            <span className="text-foreground">Unlimited Lead & Property Management</span>
                        </li>
                        <li className="flex items-start">
                            <Check className="h-5 w-5 text-primary mr-2 mt-0.5 flex-shrink-0" />
                            <span className="text-foreground">Team Collaboration Features</span>
                        </li>
                    </ul>

                    <form action={checkoutAction}>
                        <input type="hidden" name="priceId" value={platformAccessPriceId} />
                        <SubmitButton />
                    </form>
                </CardContent>
            </Card>
        </main>
    );
}


================================================
FILE: app/(dashboard)/pricing/submit-button.tsx
================================================
'use client';

import { Button } from '@/components/ui/button';
import { ArrowRight, Loader2 } from 'lucide-react';
import { useFormStatus } from 'react-dom';

export function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <Button
      type="submit"
      disabled={pending}
      variant="default" // Changed from "outline" to "default"
      className="w-full rounded-full text-lg"
    >
      {pending ? (
        <>
          <Loader2 className="animate-spin mr-2 h-4 w-4" />
          Loading...
        </>
      ) : (
        <>
          Get Started
          <ArrowRight className="ml-2 h-4 w-4" />
        </>
      )}
    </Button>
  );
}


================================================
FILE: app/(login)/actions.ts
================================================
// app/(login)/actions.ts

'use server';

import { z } from 'zod';
import { and, eq, sql } from 'drizzle-orm';
import Papa from 'papaparse';
import { db } from '@/lib/db/drizzle';
import {
  User,
  users,
  teams,
  teamMembers,
  activityLogs,
  invitations,
  contracts, // Import contracts table
  type NewUser,
  type NewTeam,
  type NewTeamMember,
  type NewActivityLog,
  type Trec14ContractData, // Import the TS Type
  ActivityType,
} from '@/lib/db/schema';
import { comparePasswords, hashPassword, setSession } from '@/lib/auth/session';
import { redirect } from 'next/navigation';
import { cookies } from 'next/headers';
import { createCheckoutSession } from '@/lib/payments/stripe';
import { getUser, getUserWithTeam } from '@/lib/db/queries';
import {
  validatedAction,
  validatedActionWithUser,
} from '@/lib/auth/middleware';
import { Trec14Schema } from '@/lib/contracts/validation'; // Import Zod Validator
import { mapCsvRowToJson } from '@/lib/contracts/transformation'; // Import CSV Transformer

// --- All other actions (signIn, signUp, signOut, etc.) remain unchanged ---
// (The full file content is provided for safe replacement)

// --- START: Existing Actions (No changes needed here) ---

async function logActivity(
  teamId: number | null | undefined,
  userId: number,
  type: ActivityType,
  ipAddress?: string
) {
  if (teamId === null || teamId === undefined) {
    return;
  }
  const newActivity: NewActivityLog = {
    teamId,
    userId,
    action: type,
    ipAddress: ipAddress || ''
  };
  await db.insert(activityLogs).values(newActivity);
}

const signInSchema = z.object({
  email: z.string().email().min(3).max(255),
  password: z.string().min(8).max(100)
});
export const signIn = validatedAction(signInSchema, async (data, formData) => {
  const { email, password } = data;
  const userWithTeam = await db
    .select({ user: users, team: teams })
    .from(users)
    .leftJoin(teamMembers, eq(users.id, teamMembers.userId))
    .leftJoin(teams, eq(teamMembers.teamId, teams.id))
    .where(eq(users.email, email))
    .limit(1);
  if (userWithTeam.length === 0) {
    return { error: 'Invalid email or password. Please try again.', email, password };
  }
  const { user: foundUser, team: foundTeam } = userWithTeam[0];
  const isPasswordValid = await comparePasswords(password, foundUser.passwordHash);
  
  if (!isPasswordValid) {
    return { error: 'Invalid email or password. Please try again.', email, password };
  }
  await Promise.all([
    setSession(foundUser),
    logActivity(foundTeam?.id, foundUser.id, ActivityType.SIGN_IN)
  ]);
  const redirectTo = formData.get('redirect') as string | null;
  if (redirectTo === 'checkout') {
    const priceId = formData.get('priceId') as string;
    return createCheckoutSession({ team: foundTeam, priceId });
  }
  redirect('/dashboard');
});

const signUpSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  inviteId: z.string().optional()
});
export const signUp = validatedAction(signUpSchema, async (data, formData) => {
  const { email, password, inviteId } = data;
  const existingUser = await db.select().from(users).where(eq(users.email, email)).limit(1);
  if (existingUser.length > 0) {
    return { error: 'An account with this email already exists.', email, password };
  }
  const passwordHash = await hashPassword(password);
  const newUser: NewUser = { email, passwordHash, role: 'owner' };
  const [createdUser] = await db.insert(users).values(newUser).returning();
  if (!createdUser) {
    return { error: 'Failed to create user. Please try again.', email, password };
  }
  let teamId: number;
  let userRole: string;
  let createdTeam: typeof teams.$inferSelect | null = null;
  if (inviteId) {
    const [invitation] = await db.select().from(invitations).where(and(eq(invitations.id, parseInt(inviteId)), eq(invitations.email, email), eq(invitations.status, 'pending'))).limit(1);
    if (invitation) {
      teamId = invitation.teamId;
      userRole = invitation.role;
      await db.update(invitations).set({ status: 'accepted' }).where(eq(invitations.id, invitation.id));
      await logActivity(teamId, createdUser.id, ActivityType.ACCEPT_INVITATION);
      [createdTeam] = await db.select().from(teams).where(eq(teams.id, teamId)).limit(1);
    } else {
      return { error: 'Invalid or expired invitation.', email, password };
    }
  } else {
    const newTeam: NewTeam = { name: `${email}'s Team` };
    [createdTeam] = await db.insert(teams).values(newTeam).returning();
    if (!createdTeam) {
      return { error: 'Failed to create team. Please try again.', email, password };
    }
    teamId = createdTeam.id;
    userRole = 'owner';
    await logActivity(teamId, createdUser.id, ActivityType.CREATE_TEAM);
  }
  const newTeamMember: NewTeamMember = { userId: createdUser.id, teamId: teamId, role: userRole };
  await Promise.all([
    db.insert(teamMembers).values(newTeamMember),
    logActivity(teamId, createdUser.id, ActivityType.SIGN_UP),
    setSession(createdUser)
  ]);
  const redirectTo = formData.get('redirect') as string | null;
  if (redirectTo === 'checkout') {
    const priceId = formData.get('priceId') as string;
    return createCheckoutSession({ team: createdTeam, priceId });
  }
  redirect('/dashboard');
});

export async function signOut() {
  const user = (await getUser()) as User;
  const userWithTeam = await getUserWithTeam(user.id);
  await logActivity(userWithTeam?.teamId, user.id, ActivityType.SIGN_OUT);
  (await cookies()).delete('session');
}

const updatePasswordSchema = z.object({
  currentPassword: z.string().min(8).max(100),
  newPassword: z.string().min(8).max(100),
  confirmPassword: z.string().min(8).max(100)
});
export const updatePassword = validatedActionWithUser(
  updatePasswordSchema,
  async (data, _, user) => {
    const { currentPassword, newPassword, confirmPassword } = data;
    const isPasswordValid = await comparePasswords(currentPassword, user.passwordHash);
    if (!isPasswordValid) {
      return { currentPassword, newPassword, confirmPassword, error: 'Current password is incorrect.' };
    }
    if (currentPassword === newPassword) {
      return { currentPassword, newPassword, confirmPassword, error: 'New password must be different from the current password.' };
    }
    if (confirmPassword !== newPassword) {
      return { currentPassword, newPassword, confirmPassword, error: 'New password and confirmation password do not match.' };
    }
    const newPasswordHash = await hashPassword(newPassword);
    const userWithTeam = await getUserWithTeam(user.id);
    await Promise.all([
      db.update(users).set({ passwordHash: newPasswordHash }).where(eq(users.id, user.id)),
      logActivity(userWithTeam?.teamId, user.id, ActivityType.UPDATE_PASSWORD)
    ]);
    return { success: 'Password updated successfully.' };
  }
);

const deleteAccountSchema = z.object({
  password: z.string().min(8).max(100)
});
export const deleteAccount = validatedActionWithUser(
  deleteAccountSchema,
  async (data, _, user) => {
    const { password } = data;
    const isPasswordValid = await comparePasswords(password, user.passwordHash);
    if (!isPasswordValid) {
      return { password, error: 'Incorrect password. Account deletion failed.' };
    }
    const userWithTeam = await getUserWithTeam(user.id);
    await logActivity(userWithTeam?.teamId, user.id, ActivityType.DELETE_ACCOUNT);
    await db
      .update(users)
      .set({
        deletedAt: sql`CURRENT_TIMESTAMP`,
        email: sql`CONCAT(email, '-', id, '-deleted')`
      })
      .where(eq(users.id, user.id));
    if (userWithTeam?.teamId) {
      await db
        .delete(teamMembers)
        .where(
          and(
            eq(teamMembers.userId, user.id),
            eq(teamMembers.teamId, userWithTeam.teamId)
          )
        );
    }
    (await cookies()).delete('session');
    redirect('/sign-in');
  }
);

const updateAccountSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  email: z.string().email('Invalid email address'),
  phone: z.string().optional(),
  marketingEmailConsent: z.enum(['on', 'off']).optional(),
  marketingSmsConsent: z.enum(['on', 'off']).optional()
});
export const updateAccount = validatedActionWithUser(
  updateAccountSchema,
  async (data, _, user) => {
    const { name, phone, marketingEmailConsent, marketingSmsConsent } = data;
    const userWithTeam = await getUserWithTeam(user.id);
    await Promise.all([
      db.update(users).set({ 
        name,
        phone,
        marketingEmailConsent: marketingEmailConsent === 'on',
        marketingSmsConsent: marketingSmsConsent === 'on'
      }).where(eq(users.id, user.id)),
      logActivity(userWithTeam?.teamId, user.id, ActivityType.UPDATE_ACCOUNT)
    ]);
    return { name, success: 'Account updated successfully.' };
  }
);

const removeTeamMemberSchema = z.object({
  memberId: z.coerce.number()
});
export const removeTeamMember = validatedActionWithUser(
  removeTeamMemberSchema,
  async (data, _, user) => {
    const { memberId } = data;
    const userWithTeam = await getUserWithTeam(user.id);
    if (!userWithTeam?.teamId) {
      return { error: 'User is not part of a team' };
    }
    if (userWithTeam.role !== 'owner') {
      return { error: 'You do not have permission to remove team members.' };
    }
    await db.delete(teamMembers).where(and(eq(teamMembers.id, memberId), eq(teamMembers.teamId, userWithTeam.teamId)));
    await logActivity(userWithTeam.teamId, user.id, ActivityType.REMOVE_TEAM_MEMBER);
    return { success: 'Team member removed successfully' };
  }
);

const inviteTeamMemberSchema = z.object({
  email: z.string().email('Invalid email address'),
  role: z.enum(['member', 'owner'])
});
export const inviteTeamMember = validatedActionWithUser(
  inviteTeamMemberSchema,
  async (data, _, user) => {
    const { email, role } = data;
    const userWithTeam = await getUserWithTeam(user.id);
    if (!userWithTeam?.teamId) {
      return { error: 'User is not part of a team' };
    }
    const existingMember = await db.select().from(users).leftJoin(teamMembers, eq(users.id, teamMembers.userId)).where(and(eq(users.email, email), eq(teamMembers.teamId, userWithTeam.teamId))).limit(1);
    if (existingMember.length > 0) {
      return { error: 'User is already a member of this team' };
    }
    const existingInvitation = await db.select().from(invitations).where(and(eq(invitations.email, email), eq(invitations.teamId, userWithTeam.teamId), eq(invitations.status, 'pending'))).limit(1);
    if (existingInvitation.length > 0) {
      return { error: 'An invitation has already been sent to this email' };
    }
    await db.insert(invitations).values({ teamId: userWithTeam.teamId, email, role, invitedBy: user.id, status: 'pending' });
    await logActivity(userWithTeam.teamId, user.id, ActivityType.INVITE_TEAM_MEMBER);
    return { success: 'Invitation sent successfully' };
  }
);
// --- END: Existing Actions ---


// --- THIS IS THE NEW, REFACTORED ACTION ---
const processCsvSchema = z.object({
  csvFile: z.any().refine(file => file?.size > 0, 'CSV file is required.'),
});

export const processCsvFile = validatedActionWithUser(
  processCsvSchema,
  async (data, formData, user) => {
    const file = formData.get('csvFile') as File;

    // 1. Authorization & Parsing
    const userWithTeam = await getUserWithTeam(user.id);
    if (!userWithTeam?.teamId) {
      return { error: 'Authentication error: Could not find your team information.' };
    }
    const team = await db.query.teams.findFirst({ where: eq(teams.id, userWithTeam.teamId) });
    if (!team) {
      return { error: 'Database error: Could not load your team data.' };
    }
    
    const csvText = await file.text();
    const parsedCsv = Papa.parse(csvText, { header: true, skipEmptyLines: true });
    const rows = parsedCsv.data as Record<string, string>[];

    if (rows.length === 0) {
      return { error: 'The uploaded CSV file has no data rows.' };
    }

    // 2. Credit Check
    const requiredCredits = rows.length;
    if (team.contractCredits < requiredCredits) {
      return { error: `You do not have enough credits. This upload requires ${requiredCredits} credits, but you only have ${team.contractCredits}.` };
    }

    // 3. Iteration, Transformation, and Validation
    const validationErrors: string[] = [];
    const validatedData: Trec14ContractData[] = [];

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const transformedJson = mapCsvRowToJson(row);
      const result = Trec14Schema.safeParse(transformedJson);

      if (!result.success) {
        // Format Zod errors for user-friendliness
        const formattedErrors = result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');
        validationErrors.push(`Row ${i + 2}: ${formattedErrors}`); // i + 2 accounts for header row and 0-index
      } else {
        validatedData.push(result.data);
      }
    }

    // 4. Error Handling
    if (validationErrors.length > 0) {
      return { error: 'Validation failed. Please correct the errors in your CSV and try again.', validationErrors };
    }

    // 5. Atomic Transaction
    try {
      const newCreditTotal = team.contractCredits - requiredCredits;
      await db.transaction(async (tx) => {
        // Persist new contracts
        const newContractsToInsert = validatedData.map(data => ({
          teamId: team.id,
          userId: user.id,
          contractData: data, // Storing the validated JSON object
        }));
        
        if (newContractsToInsert.length > 0) {
            await tx.insert(contracts).values(newContractsToInsert);
        }

        // Deduct credits
        await tx.update(teams).set({ contractCredits: newCreditTotal }).where(eq(teams.id, team.id));
      });
      // 6. Success
      return { success: `Successfully validated and saved ${requiredCredits} contracts. Your new credit balance is ${newCreditTotal}.` };
    } catch (e: any) {
      console.error("Database transaction failed:", e);
      return { error: 'A database error occurred while saving your contracts. Please try again.' };
    }
  }
);


================================================
FILE: app/(login)/login.tsx
================================================
'use client';

import Link from 'next/link';
import Image from 'next/image';
import { useActionState } from 'react';
import { useSearchParams } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Loader2, ArrowLeft } from 'lucide-react';
import { signIn, signUp } from './actions';
import { ActionState } from '@/lib/auth/middleware';

export function Login({ mode = 'signin' }: { mode?: 'signin' | 'signup' }) {
  const searchParams = useSearchParams();
  const redirect = searchParams.get('redirect');
  const priceId = searchParams.get('priceId');
  const inviteId = searchParams.get('inviteId');

  const [state, formAction, pending] = useActionState<ActionState, FormData>(
    mode === 'signin' ? signIn : signUp,
    { error: '' }
  );

  return (
    <div className="min-h-[100dvh] flex flex-col justify-center py-12 px-4 sm:px-6 lg:px-8 bg-background">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <div className="flex justify-center">
          <Image
            src="/Lazily-Text.png"
            alt="Lazily.AI Logo"
            width={180}
            height={48}
            className="h-12 w-auto"
            priority
          />
        </div>
        <h2 className="mt-6 text-center text-3xl font-bold tracking-tight text-foreground">
          {mode === 'signin'
            ? 'Welcome Back'
            : 'Get Started with Lazily.AI'}
        </h2>
      </div>

      <div className="mt-6 text-center">
        <Link
          href="/"
          className="text-sm inline-flex items-center gap-2 text-muted-foreground hover:text-foreground transition-colors"
        >
          <ArrowLeft className="h-4 w-4" />
          <span>Back to Home</span>
        </Link>
      </div>

      <div className="mt-4 sm:mx-auto sm:w-full sm:max-w-md">
        <Card className="p-8">
          <form className="space-y-6" action={formAction}>
            <input type="hidden" name="redirect" value={redirect || ''} />
            <input type="hidden" name="priceId" value={priceId || ''} />
            <input type="hidden" name="inviteId" value={inviteId || ''} />
            <div>
              <Label htmlFor="email">
                Email
              </Label>
              <div className="mt-1">
                <Input
                  id="email"
                  name="email"
                  type="email"
                  autoComplete="email"
                  defaultValue={state.email}
                  required
                  maxLength={50}
                  placeholder="Enter your email"
                />
              </div>
            </div>

            <div>
              <Label htmlFor="password">
                Password
              </Label>
              <div className="mt-1">
                <Input
                  id="password"
                  name="password"
                  type="password"
                  autoComplete={
                    mode === 'signin' ? 'current-password' : 'new-password'
                  }
                  defaultValue={state.password}
                  required
                  minLength={8}
                  maxLength={100}
                  placeholder="Enter your password"
                />
              </div>
            </div>

            {state?.error && (
              <p className="text-sm text-destructive">{state.error}</p>
            )}

            <div>
              <Button
                type="submit"
                className="w-full rounded-full"
                disabled={pending}
              >
                {pending ? (
                  <>
                    <Loader2 className="animate-spin mr-2 h-4 w-4" />
                    Loading...
                  </>
                ) : mode === 'signin' ? (
                  'Sign In'
                ) : (
                  'Create Account'
                )}
              </Button>
            </div>
          </form>

          <div className="mt-6">
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-border" />
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="px-2 bg-card text-muted-foreground">
                  {mode === 'signin'
                    ? 'New to Lazily.AI?'
                    : 'Already have an account?'}
                </span>
              </div>
            </div>

            <div className="mt-6">
              <Button asChild variant="outline" className="w-full rounded-full">
                <Link
                  href={`${mode === 'signin' ? '/sign-up' : '/sign-in'}${
                    redirect ? `?redirect=${redirect}` : ''
                  }${priceId ? `&priceId=${priceId}` : ''}`}
                >
                  {mode === 'signin'
                    ? 'Create an account'
                    : 'Sign in'}{/* <-- THE FIX WAS HERE (missing colon) */}
                </Link>
              </Button>
            </div>
          </div>
        </Card>
      </div>
    </div>
  );
}


================================================
FILE: app/(login)/sign-in/page.tsx
================================================
import { Suspense } from 'react';
import { Login } from '../login';

export default function SignInPage() {
  return (
    <Suspense>
      <Login mode="signin" />
    </Suspense>
  );
}



================================================
FILE: app/(login)/sign-up/page.tsx
================================================
import { Suspense } from 'react';
import { Login } from '../login';

export default function SignUpPage() {
  return (
    <Suspense>
      <Login mode="signup" />
    </Suspense>
  );
}



================================================
FILE: app/(marketing)/articles/page.tsx
================================================
import { getSortedPostsData } from '@/lib/content/posts';
import Link from 'next/link';

export default function ArticlesPage() {
  const allPostsData = getSortedPostsData();

  return (
    <main className="container mx-auto max-w-3xl py-16 px-6">
      <h1 className="text-4xl font-extrabold tracking-tight text-gray-800 mb-8">
        Blog
      </h1>
      <ul className="space-y-4">
        {allPostsData.map(({ slug, date, title }) => (
          <li key={slug}>
            <Link href={`/articles/${slug}`}>
              <a className="text-2xl font-bold text-blue-600 hover:underline">
                {title}
              </a>
            </Link>
            <p className="text-lg text-gray-500">{date}</p>
          </li>
        ))}
      </ul>
    </main>
  );
}



================================================
FILE: app/(marketing)/articles/[slug]/page.tsx
================================================
import { getPostData, getAllPostSlugs } from '@/lib/content/posts';
import { notFound } from 'next/navigation';
import { MDXRemote } from 'next-mdx-remote/rsc';

// Define the type for page props, correctly indicating params is a Promise
// and assuming getPostData returns a flat object as per the error message.
type PostData = {
  date: string;
  title: string;
  slug: string;
  content: string;
};

type PageProps = {
  params: Promise<{ slug: string }>;
};

export async function generateStaticParams() {
  const paths = getAllPostSlugs();
  return paths;
}

// Corrected: params type is Promise and is awaited.
// Corrected: Accessing title directly on post.
export async function generateMetadata({ params }: PageProps) {
  try {
    const { slug } = await params; // Await the params Promise [3, 4]
    // Await getPostData, and assume it returns PostData structure.
    const post: PostData = await getPostData(slug); // Await the getPostData Promise [User's current query, 77]
    return {
      title: post.title, // Corrected: Access title directly
    };
  } catch (error) {
    return {
      title: 'Post Not Found',
    };
  }
}

// Corrected: params type is Promise and is awaited.
// Corrected: Accessing title and date directly on post.
export default async function Post({ params }: PageProps) {
  let post: PostData;
  try {
    const { slug } = await params; // Await the params Promise [3, 4]
    post = await getPostData(slug); // Await the getPostData Promise [User's current query, 77]
  } catch (error) {
    notFound(); // Use Next.js notFound function for 404 [5, 6]
  }

  return (
    <main className="container mx-auto max-w-3xl py-16 px-6">
      <article className="prose lg:prose-xl">
        <h1 className="text-4xl font-extrabold tracking-tight text-gray-800 mb-2">
          {post.title} {/* Corrected: Access title directly */}
        </h1>
        <p className="text-lg text-gray-500 mb-8">{post.date}</p> {/* Corrected: Access date directly */}
        <MDXRemote source={post.content} />
      </article>
    </main>
  );
}


================================================
FILE: app/api/properties/route.ts
================================================
// app/api/properties/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { fetchProperties } from '@/lib/properties/queries';
import type { Property } from '@/lib/db/schema'; // CORRECTED IMPORT

export async function GET(request: NextRequest) {
  try {
    const properties: Property[] = await fetchProperties();
    return NextResponse.json(properties);
  } catch (error) {
    console.error('Error fetching properties:', error);
    return NextResponse.json(
      { error: 'Failed to fetch properties' },
      { status: 500 }
    );
  }
}


================================================
FILE: app/api/stripe/agents.md
================================================
# Lazily.AI: Stripe API Agent Guide

This `AGENTS.md` provides specific guidance for working within the `app/api/stripe` directory.

## 1. Core Responsibility

This module is responsible for the **secure and reliable processing of all payment-related events and API calls** via Stripe, supporting both recurring subscriptions and one-time credit purchases.

## 2. Key Files & Directives

*   **`webhook/route.ts`**:
    *   **Webhook security is CRITICAL.** Always verify the `stripe-signature` in the request header using `stripe.webhooks.constructEvent()` to ensure requests originate from Stripe [32, 33]. **Never bypass this verification.**
    *   **Implement idempotency** for all webhook event processing, especially for credit purchases. Check if a `stripeCheckoutSessionId` has already been processed before updating the database to prevent duplicate credit grants [28, 34].
    *   Differentiate between `session.mode === 'payment'` (for credits) and `session.mode === 'subscription'` (for platform access) to apply correct fulfillment logic [35, 36].
    *   Ensure appropriate HTTP status codes are returned (e.g., 200 OK for successful processing, 500 for internal errors that Stripe should retry) [37].

*   **`checkout/route.ts`**:
    *   Handles the post-checkout logic, including retrieving session details and updating team subscription status in the database [30, 38].

## 3. Development Workflow

*   **All Stripe-related API calls and webhook handling must use the official Stripe Node.js library** (`stripe`) [39, 40].
*   When creating checkout sessions (via `lib/payments/actions.ts`), **always include `client_reference_id` and `metadata`** to link the Stripe session back to the user and team in the application database [41, 42].
*   Be mindful of sensitive API keys and secrets. **Always use environment variables** (`process.env.STRIPE_SECRET_KEY`, `process.env.STRIPE_WEBHOOK_SECRET`) and never hardcode them [33, 39, 40].




================================================
FILE: app/api/stripe/checkout/route.ts
================================================
import { eq } from 'drizzle-orm';
import { db } from '@/lib/db/drizzle';
import { users, teams, teamMembers } from '@/lib/db/schema';
import { setSession } from '@/lib/auth/session';
import { NextRequest, NextResponse } from 'next/server';
import { stripe } from '@/lib/payments/stripe';
import Stripe from 'stripe';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const sessionId = searchParams.get('session_id');

  if (!sessionId) {
    return NextResponse.redirect(new URL('/pricing', request.url));
  }

  try {
    const session = await stripe.checkout.sessions.retrieve(sessionId, {
      expand: ['customer', 'subscription'],
    });

    if (!session.customer || typeof session.customer === 'string') {
      throw new Error('Invalid customer data from Stripe.');
    }

    const customerId = session.customer.id;
    const subscriptionId =
      typeof session.subscription === 'string'
        ? session.subscription
        : session.subscription?.id;

    if (!subscriptionId) {
      throw new Error('No subscription found for this session.');
    }

    const subscription = await stripe.subscriptions.retrieve(subscriptionId, {
      expand: ['items.data.price.product'],
    });

    const plan = subscription.items.data[0]?.price;

    if (!plan) {
      throw new Error('No plan found for this subscription.');
    }

    const productId = (plan.product as Stripe.Product).id;

    if (!productId) {
      throw new Error('No product ID found for this subscription.');
    }

    const userId = session.client_reference_id;
    if (!userId) {
      throw new Error("No user ID found in session's client_reference_id.");
    }

    const user = await db
      .select()
      .from(users)
      .where(eq(users.id, Number(userId)))
      .limit(1);

    if (user.length === 0) {
      throw new Error('User not found in database.');
    }

    const userTeam = await db
      .select({
        teamId: teamMembers.teamId,
      })
      .from(teamMembers)
      .where(eq(teamMembers.userId, user[0].id))
      .limit(1);

    if (userTeam.length === 0) {
      throw new Error('User is not associated with any team.');
    }

    await db
      .update(teams)
      .set({
        stripeCustomerId: customerId,
        stripeSubscriptionId: subscriptionId,
        stripeProductId: productId,
        planName: (plan.product as Stripe.Product).name,
        subscriptionStatus: subscription.status,
        updatedAt: new Date(),
      })
      .where(eq(teams.id, userTeam[0].teamId));

    await setSession(user[0]);
    return NextResponse.redirect(new URL('/dashboard', request.url));
  } catch (error) {
    console.error('Error handling successful checkout:', error);
    return NextResponse.redirect(new URL('/error', request.url));
  }
}



================================================
FILE: app/api/stripe/webhook/agents.md
================================================
# Lazily.AI: Stripe Webhook Agent Guide

**CRITICAL INSTRUCTIONS:** This `AGENTS.md` provides security-critical directives for the Stripe webhook handler. Failure to follow these rules can result in financial discrepancies and security vulnerabilities.

## 1. Core Responsibility

This endpoint's sole function is to **securely receive, verify, and process asynchronous events from Stripe**. It is the automated fulfillment center for all purchases.

## 2. Security & Reliability Directives

1.  **Verify Signature First:** The **very first action** in the `POST` handler **must** be to verify the `stripe-signature` header using `stripe.webhooks.constructEvent`. Any request that fails this verification must be immediately rejected with a `400` status code. Do not process the payload until the signature is verified.

2.  **Ensure Idempotency:** Webhooks can be sent more than once by Stripe. Your logic **must be idempotent** to prevent duplicate processing (e.g., awarding credits twice for one purchase). Before performing any action, check if the event has already been processed. For `checkout.session.completed` events, this is done by checking if the `session.id` already exists in our `creditPurchases` or subscription log table.

3.  **Acknowledge Events Immediately:** You **must** return a `200` status code to Stripe as quickly as possible to acknowledge that you have received the event. If you fail to do this, Stripe will consider the delivery a failure and will retry, potentially leading to duplicate events.

## 3. Architectural Pattern

* **Keep This Route Simple:** This `route.ts` file should act only as a secure "router."
* **Delegate Business Logic:** Once an event is verified and received, immediately delegate the actual business logic (like updating a database table) to a dedicated handler function in `lib/payments/stripe.ts` (e.g., `handleCreditPurchase`). This keeps the API route clean and separates concerns.


================================================
FILE: app/api/stripe/webhook/route.ts
================================================
import Stripe from 'stripe';
import {
  handleSubscriptionChange,
  stripe,
  handleCreditPurchase,
  handleSubscriptionPurchase,
} from '@/lib/payments/stripe';
import { NextRequest, NextResponse } from 'next/server';

const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;

export async function POST(request: NextRequest) {
  const payload = await request.text();
  const signature = request.headers.get('stripe-signature') as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(payload, signature, webhookSecret);
  } catch (err) {
    console.error('Webhook signature verification failed.', err);
    return NextResponse.json(
      { error: 'Webhook signature verification failed.' },
      { status: 400 }
    );
  }

  switch (event.type) {
    case 'customer.subscription.updated':
    case 'customer.subscription.deleted':
      const subscription = event.data.object as Stripe.Subscription;
      await handleSubscriptionChange(subscription, event.type);
      break;
    case 'checkout.session.completed':
      const session = event.data.object as Stripe.Checkout.Session;
      if (session.mode === 'payment') {
        await handleCreditPurchase(session);
      } else if (session.mode === 'subscription') {
        await handleSubscriptionPurchase(session);
      }
      break;
    default:
      console.log(`Unhandled event type ${event.type}`);
  }

  return NextResponse.json({ received: true });
}



================================================
FILE: app/api/team/route.ts
================================================
import { getTeamForUser } from '@/lib/db/queries';

export async function GET() {
  const team = await getTeamForUser();
  return Response.json(team);
}



================================================
FILE: app/api/team/credits/route.ts
================================================
// app/api/team/credits/route.ts

import { getTeamForUser } from '@/lib/db/queries';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    const team = await getTeamForUser();

    if (!team) {
      return new NextResponse('Team not found', { status: 404 });
    }

    return NextResponse.json({ credits: team.contractCredits });
  } catch (error) {
    console.error('Failed to fetch credits:', error);
    return new NextResponse('Internal Server Error', { status: 500 });
  }
}


================================================
FILE: app/api/user/route.ts
================================================
import { getUser } from '@/lib/db/queries';

export async function GET() {
  const user = await getUser();
  return Response.json(user);
}



================================================
FILE: components/dashboard/ContractList.tsx
================================================
// components/dashboard/ContractList.tsx

import { getContractsForUser } from '@/lib/db/queries';
import { Trec14ContractData } from '@/lib/contracts/validation';
import { DownloadContractButton } from './DownloadContractButton'; // Import the new button

export async function ContractList() {
  const userContracts = await getContractsForUser();

  return (
    <div className="border-t">
      {userContracts.length === 0 ? (
        <p className="p-4 text-sm text-muted-foreground">No contracts found.</p>
      ) : (
        <ul className="divide-y divide-border">
          {userContracts.map((contract) => {
            const data = contract.contractData as Trec14ContractData;

            return (
              <li key={contract.id} className="p-4 flex justify-between items-center">
                <div>
                  <p className="font-medium">
                    {data.property?.address || 'Address not available'}
                  </p>
                  <p className="text-sm text-muted-foreground">
                    Seller: {data.parties?.seller || 'N/A'}
                  </p>
                  <p className="text-sm text-muted-foreground">
                    Sales Price: ${data.price?.salesPrice || 'N/A'}
                  </p>
                </div>
                <div>
                  {/* Use the new, functional button */}
                  <DownloadContractButton 
                    contractId={contract.id} 
                    contractAddress={data.property?.address || null}
                  />
                </div>
              </li>
            );
          })}
        </ul>
      )}
    </div>
  );
}


================================================
FILE: components/dashboard/CreditRefresher.tsx
================================================
'use client';

import { useSearchParams } from 'next/navigation';
import { useEffect } from 'react';
import { useSWRConfig } from 'swr';

export function CreditRefresher() {
  const { mutate } = useSWRConfig();
  const searchParams = useSearchParams();
  const success = searchParams.get('success');

  useEffect(() => {
    if (success === 'true') {
      mutate('/api/team/credits');
    }
  }, [success, mutate]);

  return null; // This component doesn't render anything
}


================================================
FILE: components/dashboard/CreditsCounter.tsx
================================================
// components/dashboard/CreditsCounter.tsx

'use client';

import useSWR from 'swr';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { FileText } from 'lucide-react';

const fetcher = (url: string) => fetch(url).then((res) => res.json());

export function CreditsCounter() {
  const { data, error } = useSWR('/api/team/credits', fetcher);

  const credits = data?.credits;

  if (error) return <div>Failed to load credits</div>;

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">Available Credits</CardTitle>
        <FileText className="h-4 w-4 text-muted-foreground" />
      </CardHeader> {/* <-- This was the line with the typo */}
      <CardContent>
        <div className="text-2xl font-bold">
          {credits !== undefined ? credits : '...'}
        </div>
        <p className="text-xs text-muted-foreground">
          1 credit is used per generated contract.
        </p>
      </CardContent>
    </Card>
  );
}


================================================
FILE: components/dashboard/CsvUploadForm.tsx
================================================
// components/dashboard/CsvUploadForm.tsx

'use client';

import { useActionState } from 'react';
import Link from 'next/link';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { processCsvFile } from '@/app/(login)/actions';
import { ActionState } from '@/lib/auth/middleware';
import { UploadErrorViewer } from './UploadErrorViewer'; // Import the new component
import { Download, UploadCloud } from 'lucide-react';

export function CsvUploadForm() {
  const [state, formAction, isPending] = useActionState<ActionState>(processCsvFile as any, { error: '', validationErrors: [] });

  return (
    <div>
      <form action={formAction} className="space-y-4">
        <div>
          <Label htmlFor="csv-upload">Upload Your CSV File</Label>
          <div className="flex flex-col sm:flex-row gap-4 mt-1">
            <Input id="csv-upload" name="csvFile" type="file" accept=".csv" required className="max-w-xs" />
            <Button type="submit" disabled={isPending}>
              {isPending ? (
                'Uploading...'
              ) : (
                <>
                  <UploadCloud className="mr-2 h-4 w-4" />
                  Upload and Process
                </>
              )}
            </Button>
          </div>
        </div>
      </form>

      <div className="mt-6">
        <p className="text-sm text-muted-foreground">
          Don't have the template? Download it here to get started.
        </p>
        <Button asChild variant="outline" className="mt-2">
          <Link href="/templates/lazily-ai-template.csv" download>
            <Download className="mr-2 h-4 w-4" />
            Download Template
          </Link>
        </Button>
      </div>

      {/* Display errors using the new component */}
      {state?.error && <UploadErrorViewer errors={[state.error]} />}
      {state?.validationErrors && <UploadErrorViewer errors={state.validationErrors} />}
      
      {state?.success && <p className="mt-4 text-green-600">{state.success}</p>}
    </div>
  );
}


================================================
FILE: components/dashboard/DownloadContractButton.tsx
================================================
// components/dashboard/DownloadContractButton.tsx

'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Download, Loader2 } from 'lucide-react';
import { generateContractAction } from '@/app/(dashboard)/dashboard/contracts/actions';

export function DownloadContractButton({ contractId, contractAddress }: { contractId: number; contractAddress: string | null }) {
  const [isLoading, setIsLoading] = useState(false);

  const handleDownload = async () => {
    setIsLoading(true);
    try {
      // Call the server action to get the PDF bytes
      const pdfBytes = await generateContractAction(contractId);
      
      // Use the browser to create a downloadable file from the bytes
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `TREC_Contract_${contractAddress || contractId}.pdf`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

    } catch (error) {
      console.error('Failed to generate PDF:', error);
      alert('There was an error generating your PDF. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button variant="outline" size="sm" onClick={handleDownload} disabled={isLoading}>
      {isLoading ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          Generating...
        </>
      ) : (
        <>
          <Download className="mr-2 h-4 w-4" />
          Download PDF
        </>
      )}
    </Button>
  );
}


================================================
FILE: components/dashboard/UploadErrorViewer.tsx
================================================
// components/dashboard/UploadErrorViewer.tsx

import { AlertCircle } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface UploadErrorViewerProps {
  errors: string[];
}

export function UploadErrorViewer({ errors }: UploadErrorViewerProps) {
  if (!errors || errors.length === 0) {
    return null;
  }

  return (
    <Card className="mt-4 border-destructive bg-destructive/10">
      <CardHeader className="flex flex-row items-center gap-2 space-y-0 pb-2">
        <AlertCircle className="h-5 w-5 text-destructive" />
        <CardTitle className="text-destructive text-base">
          Upload Failed: Please fix the following {errors.length > 1 ? 'errors' : 'error'}:
        </CardTitle>
      </CardHeader>
      <CardContent>
        <ul className="list-disc list-inside space-y-1 text-sm text-destructive">
          {errors.map((error, index) => (
            <li key={index}>{error}</li>
          ))}
        </ul>
      </CardContent>
    </Card>
  );
}


================================================
FILE: components/ui/avatar.tsx
================================================
"use client";

import * as React from "react";
import { Avatar as AvatarPrimitive } from "radix-ui";;

import { cn } from "@/lib/styles/utils";

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  );
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  );
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  );
}

export { Avatar, AvatarImage, AvatarFallback };



================================================
FILE: components/ui/button.tsx
================================================
import * as React from "react";
import { Slot as SlotPrimitive } from "radix-ui";;
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/styles/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? SlotPrimitive.Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };



================================================
FILE: components/ui/card.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/styles/utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  );
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent
};



================================================
FILE: components/ui/checkbox.tsx
================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/styles/utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }



================================================
FILE: components/ui/dropdown-menu.tsx
================================================
"use client";

import * as React from "react";
import { DropdownMenu as DropdownMenuPrimitive } from "radix-ui";;
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";

import { cn } from "@/lib/styles/utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent
};



================================================
FILE: components/ui/input.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/styles/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  );
}

export { Input };



================================================
FILE: components/ui/label.tsx
================================================
"use client";

import * as React from "react";
import { Label as LabelPrimitive } from "radix-ui";;

import { cn } from "@/lib/styles/utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  );
}

export { Label };



================================================
FILE: components/ui/radio-group.tsx
================================================
"use client";

import * as React from "react";
import { RadioGroup as RadioGroupPrimitive } from "radix-ui";;
import { CircleIcon } from "lucide-react";

import { cn } from "@/lib/styles/utils";

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  );
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
}

export { RadioGroup, RadioGroupItem };



================================================
FILE: lib/data.ts
================================================
[Empty file]


================================================
FILE: lib/definitions.ts
================================================
[Empty file]


================================================
FILE: lib/posts.ts
================================================
[Empty file]


================================================
FILE: lib/utils.ts
================================================
[Empty file]


================================================
FILE: lib/auth/middleware.ts
================================================
import { z } from 'zod';
import { TeamDataWithMembers, User } from '@/lib/db/schema';
import { getTeamForUser, getUser } from '@/lib/db/queries';
import { redirect } from 'next/navigation';

export type ActionState = {
  error?: string;
  success?: string;
  validationErrors?: string[];
  [key: string]: any; // This allows for additional properties
};

type ValidatedActionFunction<S extends z.ZodType<any, any>, T> = (
  data: z.infer<S>,
  formData: FormData
) => Promise<T>;

export function validatedAction<S extends z.ZodType<any, any>, T>(
  schema: S,
  action: ValidatedActionFunction<S, T>
) {
  return async (prevState: ActionState, formData: FormData) => {
    const result = schema.safeParse(Object.fromEntries(formData));
    if (!result.success) {
      return { error: result.error.errors[0].message };
    }

    return action(result.data, formData);
  };
}

type ValidatedActionWithUserFunction<S extends z.ZodType<any, any>, T> = (
  data: z.infer<S>,
  formData: FormData,
  user: User
) => Promise<T>;

export function validatedActionWithUser<S extends z.ZodType<any, any>, T>(
  schema: S,
  action: ValidatedActionWithUserFunction<S, T>
) {
  return async (prevState: ActionState, formData: FormData) => {
    const user = await getUser();
    if (!user) {
      throw new Error('User is not authenticated');
    }

    const result = schema.safeParse(Object.fromEntries(formData));
    if (!result.success) {
      return { error: result.error.errors[0].message };
    }

    return action(result.data, formData, user);
  };
}

type ActionWithTeamFunction<T> = (
  formData: FormData,
  team: TeamDataWithMembers
) => Promise<T>;

export function withTeam<T>(action: ActionWithTeamFunction<T>) {
  return async (formData: FormData): Promise<T> => {
    const user = await getUser();
    if (!user) {
      redirect('/sign-in');
    }

    const team = await getTeamForUser();
    if (!team) {
      throw new Error('Team not found');
    }

    return action(formData, team);
  };
}



================================================
FILE: lib/auth/session.ts
================================================
import { compare, hash } from 'bcryptjs';
import { SignJWT, jwtVerify } from 'jose';
import { cookies } from 'next/headers';
import { NewUser } from '@/lib/db/schema';

const key = new TextEncoder().encode(process.env.AUTH_SECRET);
const SALT_ROUNDS = 10;

export async function hashPassword(password: string) {
  return hash(password, SALT_ROUNDS);
}

export async function comparePasswords(
  plainTextPassword: string,
  hashedPassword: string
) {
  return compare(plainTextPassword, hashedPassword);
}

type SessionData = {
  user: { id: number };
  expires: string;
};

export async function signToken(payload: SessionData) {
  return await new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('1 day from now')
    .sign(key);
}

export async function verifyToken(input: string) {
  const { payload } = await jwtVerify(input, key, {
    algorithms: ['HS256'],
  });
  return payload as SessionData;
}

export async function getSession() {
  const session = (await cookies()).get('session')?.value;
  if (!session) return null;
  return await verifyToken(session);
}

export async function setSession(user: NewUser) {
  const expiresInOneDay = new Date(Date.now() + 24 * 60 * 60 * 1000);
  const session: SessionData = {
    user: { id: user.id! },
    expires: expiresInOneDay.toISOString(),
  };
  const encryptedSession = await signToken(session);
  (await cookies()).set('session', encryptedSession, {
    expires: expiresInOneDay,
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
  });
}



================================================
FILE: lib/content/posts.ts
================================================
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const postsDirectory = path.join(process.cwd(), 'posts');

export function getSortedPostsData() {
  const fileNames = fs.readdirSync(postsDirectory);
  const allPostsData = fileNames.map((fileName) => {
    // Corrected to handle .mdx extension
    const slug = fileName.replace(/\.mdx$/, '');

    const fullPath = path.join(postsDirectory, fileName);
    const fileContents = fs.readFileSync(fullPath, 'utf8');
    const matterResult = matter(fileContents);

    return {
      slug,
      ...(matterResult.data as { date: string; title: string }),
    };
  });

  return allPostsData.sort((a, b) => {
    if (a.date < b.date) {
      return 1;
    } else {
      return -1;
    }
  });
}

export function getAllPostSlugs() {
  const fileNames = fs.readdirSync(postsDirectory);
  return fileNames.map((fileName) => {
    return {
      params: {
        // Corrected to handle .mdx extension
        slug: fileName.replace(/\.mdx$/, ''),
      },
    };
  });
}

export async function getPostData(slug: string) {
  // Corrected to handle .mdx extension
  const fullPath = path.join(postsDirectory, `${slug}.mdx`);
  const fileContents = fs.readFileSync(fullPath, 'utf8');
  const matterResult = matter(fileContents);

  return {
    slug,
    content: matterResult.content,
    ...(matterResult.data as { date: string; title: string }),
  };
}


================================================
FILE: lib/contracts/agents.md
================================================
# Lazily.AI: Contracts Module Agent Guide

This `AGENTS.md` provides specific guidance for working within the `lib/contracts` directory.

## 1. Core Responsibility

This module is critical for ensuring **data integrity and proper structuring** of all Texas Real Estate Commission (TREC) 1-4 Family Residential Contract data. It dictates how raw CSV data is interpreted, validated, and prepared for storage and PDF generation.

## 2. Key Files & Directives

*   **`validation.ts`**:
    *   **Always ensure all contract data conforms to the `Trec14Schema` defined here.** This is the **absolute single source of truth** for the contract data structure [6, 11, 19].
    *   When adding new contract fields or modifying existing ones, **first update the `Trec14Schema` in `validation.ts`**.
    *   All external data (e.g., from CSV uploads) **must be validated using this Zod schema** [9, 16, 20].

*   **`transformation.ts`**:
    *   This file contains the `mapCsvRowToJson` function, which is responsible for **meticulously mapping CSV column headers to the nested JSON structure** expected by `Trec14Schema` [7, 13, 17, 18, 21].
    *   If any CSV template columns change or new fields are added to the Zod schema, **you MUST update the mapping logic in `transformation.ts`** to correctly transform incoming CSV data [18, 21].
    *   Ensure that boolean values from CSV (e.g., 'true', 'yes', '1') are correctly converted to actual booleans using the `toBoolean` helper function [22].

## 3. Development Workflow

*   When working on features involving CSV uploads, data validation, or contract data persistence, **start by understanding the schema in `validation.ts` and the mapping in `transformation.ts`**.
*   **Prioritize type safety**: Leverage TypeScript to ensure consistency between CSV transformation, Zod validation, and database storage.




================================================
FILE: lib/contracts/transformation.ts
================================================
// lib/contracts/transformation.ts

import { Trec14ContractData } from "./validation";

const toBoolean = (value: string | undefined | null): boolean => {
  if (!value) return false;
  return ['true', 'yes', '1'].includes(value.toLowerCase());
};

export const mapCsvRowToJson = (row: Record<string, string>): Trec14ContractData => {
  return {
    parties: {
      seller: row['parties.seller'] || null,
      buyer: row['parties.buyer'] || null,
    },
    property: {
      lot: row['property.lot'] || null,
      block: row['property.block'] || null,
      addition: row['property.addition'] || null,
      city: row['property.city'] || null,
      county: row['property.county'] || null,
      address: row['property.address'] || null,
      exclusions: {
        part1: row['property.exclusions.part1'] || null,
        part2: row['property.exclusions.part2'] || null,
      },
      hoaStatus: (row['property.hoaStatus'] as any) || null,
      requiredNotices: row['property.requiredNotices'] || null,
    },
    price: {
      cashPortion: row['price.cashPortion'] || null,
      financeAmount: row['price.financeAmount'] || null,
      salesPrice: row['price.salesPrice'] || null,
    },
    financing: {
      thirdParty: toBoolean(row['financing.thirdParty']),
      loanAssumption: toBoolean(row['financing.loanAssumption']),
      seller: toBoolean(row['financing.seller']),
    },
    leases: {
      isResidential: toBoolean(row['leases.isResidential']),
      isFixture: toBoolean(row['leases.isFixture']),
      isNaturalResource: toBoolean(row['leases.isNaturalResource']),
      naturalResourceTerminationDays: row['leases.naturalResourceTerminationDays'] || null,
      naturalResourceDeliveryStatus: (row['leases.naturalResourceDeliveryStatus'] as any) || null,
    },
    earnestMoney: {
      escrowAgentName: row['earnestMoney.escrowAgentName'] || null,
      escrowAgentAddress: {
        part1: row['earnestMoney.escrowAgentAddress.part1'] || null,
        part2: row['earnestMoney.escrowAgentAddress.part2'] || null,
      },
      amount: row['earnestMoney.amount'] || null,
      additionalAmount: row['earnestMoney.additionalAmount'] || null,
      additionalAmountDays: row['earnestMoney.additionalAmountDays'] || null,
    },
    optionFee: {
      amount: row['optionFee.amount'] || null,
      days: row['optionFee.days'] || null,
    },
    titlePolicy: {
      companyName: row['titlePolicy.companyName'] || null,
      payer: (row['titlePolicy.payer'] as any) || null,
      shortageAmendment: {
        status: (row['titlePolicy.shortageAmendment.status'] as any) || null,
        payer: (row['titlePolicy.shortageAmendment.payer'] as any) || null,
      },
    },
    survey: {
      status: (row['survey.status'] as any) || null,
      existing: {
        deliveryDays: row['survey.existing.deliveryDays'] || null,
        affidavitPayer: (row['survey.existing.affidavitPayer'] as any) || null,
      },
      new: {
        deliveryDays: row['survey.new.deliveryDays'] || null,
      },
      newBySeller: {
        deliveryDays: row['survey.newBySeller.deliveryDays'] || null,
      },
    },
    objections: {
      prohibitedUseActivity: row['objections.prohibitedUseActivity'] || null,
      objectionDays: row['objections.objectionDays'] || null,
    },
    propertyCondition: {
      sellerDisclosure: {
        status: (row['propertyCondition.sellerDisclosure.status'] as any) || null,
        deliveryDays: row['propertyCondition.sellerDisclosure.deliveryDays'] || null,
      },
      acceptanceStatus: (row['propertyCondition.acceptanceStatus'] as any) || null,
      repairsList: {
        part1: row['propertyCondition.repairsList.part1'] || null,
        part2: row['propertyCondition.repairsList.part2'] || null,
      },
    },
    serviceContract: {
      maxCost: row['serviceContract.maxCost'] || null,
    },
    brokers: {
      listing: {
        associate: {
          name: row['brokers.listing.associate.name'] || null,
          licenseNo: row['brokers.listing.associate.licenseNo'] || null,
          teamName: row['brokers.listing.associate.teamName'] || null,
          email: row['brokers.listing.associate.email'] || null,
          phone: row['brokers.listing.associate.phone'] || null,
        },
        represents: (row['brokers.listing.represents'] as any) || null,
        firmName: row['brokers.listing.firmName'] || null,
        firmLicenseNo: row['brokers.listing.firmLicenseNo'] || null,
        supervisor: {
          name: row['brokers.listing.supervisor.name'] || null,
          licenseNo: row['brokers.listing.supervisor.licenseNo'] || null,
        },
        address: {
          street: row['brokers.listing.address.street'] || null,
          city: row['brokers.listing.address.city'] || null,
          state: row['brokers.listing.address.state'] || null,
          zip: row['brokers.listing.address.zip'] || null,
          phone: row['brokers.listing.address.phone'] || null,
        },
      },
      other: {
        firmName: row['brokers.other.firmName'] || null,
        firmLicenseNo: row['brokers.other.firmLicenseNo'] || null,
        represents: (row['brokers.other.represents'] as any) || null,
        associate: {
          name: row['brokers.other.associate.name'] || null,
          licenseNo: row['brokers.other.associate.licenseNo'] || null,
          teamName: row['brokers.other.associate.teamName'] || null,
          email: row['brokers.other.associate.email'] || null,
          phone: row['brokers.other.associate.phone'] || null,
        },
        supervisor: {
          name: row['brokers.other.supervisor.name'] || null,
          licenseNo: row['brokers.other.supervisor.licenseNo'] || null,
        },
        address: {
          street: row['brokers.other.address.street'] || null,
          city: row['brokers.other.address.city'] || null,
          state: row['brokers.other.address.state'] || null,
          zip: row['brokers.other.address.zip'] || null,
          phone: row['brokers.other.address.phone'] || null,
        },
      },
      disclosure: {
        fee: {
          dollarAmount: row['brokers.disclosure.fee.dollarAmount'] || null,
          percentage: row['brokers.disclosure.fee.percentage'] || null,
          type: (row['brokers.disclosure.fee.type'] as any) || null,
        },
      },
    },
    closing: {
      date: {
        monthDay: row['closing.date.monthDay'] || null,
        year: row['closing.date.year'] || null,
      },
    },
    possession: {
      status: (row['possession.status'] as any) || null,
    },
    specialProvisions: {
      text: row['specialProvisions.text'] || null,
    },
    settlement: {
      sellerContributionToBrokerage: {
        type: (row['settlement.sellerContributionToBrokerage.type'] as any) || null,
        dollarAmount: row['settlement.sellerContributionToBrokerage.dollarAmount'] || null,
        percentage: row['settlement.sellerContributionToBrokerage.percentage'] || null,
      },
      sellerContributionToOther: {
        amount: row['settlement.sellerContributionToOther.amount'] || null,
      },
    },
    notices: {
      buyer: {
        contactInfo: {
          part1: row['notices.buyer.contactInfo.part1'] || null,
          part2: row['notices.buyer.contactInfo.part2'] || null,
        },
        phone: row['notices.buyer.phone'] || null,
        emailFax: {
          '1': row['notices.buyer.emailFax.1'] || null,
          '2': row['notices.buyer.emailFax.2'] || null,
        },
      },
      seller: {
        contactInfo: {
          part1: row['notices.seller.contactInfo.part1'] || null,
          part2: row['notices.seller.contactInfo.part2'] || null,
        },
        phone: row['notices.seller.phone'] || null,
        emailFax: {
          '1': row['notices.seller.emailFax.1'] || null,
          '2': row['notices.seller.emailFax.2'] || null,
        },
      },
    },
    addenda: {
      thirdPartyFinancing: toBoolean(row['addenda.thirdPartyFinancing']),
      sellerFinancing: toBoolean(row['addenda.sellerFinancing']),
      hoa: toBoolean(row['addenda.hoa']),
      buyersTemporaryLease: toBoolean(row['addenda.buyersTemporaryLease']),
      loanAssumption: toBoolean(row['addenda.loanAssumption']),
      saleOfOtherProperty: toBoolean(row['addenda.saleOfOtherProperty']),
      mineralReservation: toBoolean(row['addenda.mineralReservation']),
      backupContract: toBoolean(row['addenda.backupContract']),
      coastalAreaProperty: toBoolean(row['addenda.coastalAreaProperty']),
      hydrostaticTesting: toBoolean(row['addenda.hydrostaticTesting']),
      lenderAppraisalTermination: toBoolean(row['addenda.lenderAppraisalTermination']),
      environmentalAssessment: toBoolean(row['addenda.environmentalAssessment']),
      sellersTemporaryLease: toBoolean(row['addenda.sellersTemporaryLease']),
      shortSale: toBoolean(row['addenda.shortSale']),
      seawardOfGulfWaterway: toBoolean(row['addenda.seawardOfGulfWaterway']),
      leadBasedPaint: toBoolean(row['addenda.leadBasedPaint']),
      propaneGasSystem: toBoolean(row['addenda.propaneGasSystem']),
      residentialLeases: toBoolean(row['addenda.residentialLeases']),
      fixtureLeases: toBoolean(row['addenda.fixtureLeases']),
      section1031Exchange: toBoolean(row['addenda.section1031Exchange']),
      improvementDistrict: toBoolean(row['addenda.improvementDistrict']),
      otherText: {
        p1: row['addenda.otherText.p1'] || null,
      },
    },
    attorneys: {
      buyer: {
        name: row['attorneys.buyer.name'] || null,
        phone: row['attorneys.buyer.phone'] || null,
        fax: row['attorneys.buyer.fax'] || null,
        email: row['attorneys.buyer.email'] || null,
      },
      seller: {
        name: row['attorneys.seller.name'] || null,
        phone: row['attorneys.seller.phone'] || null,
        fax: row['attorneys.seller.fax'] || null,
        email: row['attorneys.seller.email'] || null,
      },
    },
    execution: {
      day: row['execution.day'] || null,
      month: row['execution.month'] || null,
      year: row['execution.year'] || null,
    },
  };
};


================================================
FILE: lib/contracts/validation.ts
================================================
// lib/contracts/validation.ts

import { z } from 'zod';

// This is the final, corrected schema, matching your custom PDF fields and choices.
export const Trec14Schema = z.object({
  parties: z.object({
    seller: z.string().optional().nullable(),
    buyer: z.string().optional().nullable(),
  }),
  property: z.object({
    lot: z.string().optional().nullable(),
    block: z.string().optional().nullable(),
    addition: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    county: z.string().optional().nullable(),
    address: z.string().optional().nullable(),
    exclusions: z.object({
      part1: z.string().optional().nullable(),
      part2: z.string().optional().nullable(),
    }),
    hoaStatus: z.enum(['is_subject', 'not_subject']).optional().nullable(),
    requiredNotices: z.string().optional().nullable(),
  }),
  price: z.object({
    cashPortion: z.string().optional().nullable(),
    financeAmount: z.string().optional().nullable(),
    salesPrice: z.string().optional().nullable(),
  }),
  financing: z.object({
    thirdParty: z.boolean().optional(),
    loanAssumption: z.boolean().optional(),
    seller: z.boolean().optional(),
  }),
  leases: z.object({
    isResidential: z.boolean().optional(),
    isFixture: z.boolean().optional(),
    isNaturalResource: z.boolean().optional(),
    naturalResourceTerminationDays: z.string().optional().nullable(),
    naturalResourceDeliveryStatus: z.enum(['has_been_delivered', 'will_not_be_delivered']).optional().nullable(),
  }),
  earnestMoney: z.object({
    escrowAgentName: z.string().optional().nullable(),
    escrowAgentAddress: z.object({
      part1: z.string().optional().nullable(),
      part2: z.string().optional().nullable(),
    }),
    amount: z.string().optional().nullable(),
    additionalAmount: z.string().optional().nullable(),
    additionalAmountDays: z.string().optional().nullable(),
  }),
  optionFee: z.object({
    amount: z.string().optional().nullable(),
    days: z.string().optional().nullable(),
  }),
  titlePolicy: z.object({
    companyName: z.string().optional().nullable(),
    payer: z.enum(['Seller', 'Buyer']).optional().nullable(),
    shortageAmendment: z.object({
      status: z.enum(['shall_be_amended', 'will_not_be_amended']).optional().nullable(),
      payer: z.enum(['Seller', 'Buyer']).optional().nullable(),
    }),
  }),
  survey: z.object({
    status: z.enum(['existing_survey_provided', 'new_survey_ordered', 'new_survey_by_seller']).optional().nullable(),
    existing: z.object({
      deliveryDays: z.string().optional().nullable(),
      affidavitPayer: z.enum(['seller', 'buyer']).optional().nullable(),
    }),
    new: z.object({
      deliveryDays: z.string().optional().nullable(),
    }),
    newBySeller: z.object({
      deliveryDays: z.string().optional().nullable(),
    }),
  }),
  objections: z.object({
    prohibitedUseActivity: z.string().optional().nullable(),
    objectionDays: z.string().optional().nullable(),
  }),
  propertyCondition: z.object({
    sellerDisclosure: z.object({
      status: z.enum(['received', 'not_received', 'not_required']).optional().nullable(),
      deliveryDays: z.string().optional().nullable(),
    }),
    acceptanceStatus: z.enum(['as_is', 'as_is_with_repairs']).optional().nullable(),
    repairsList: z.object({
      part1: z.string().optional().nullable(),
      part2: z.string().optional().nullable(),
    }),
  }),
  serviceContract: z.object({
    maxCost: z.string().optional().nullable(),
  }),
  brokers: z.object({
    listing: z.object({
      associate: z.object({
        name: z.string().optional().nullable(),
        licenseNo: z.string().optional().nullable(),
        teamName: z.string().optional().nullable(),
        email: z.string().optional().nullable(),
        phone: z.string().optional().nullable(),
      }),
      represents: z.enum(["seller_agent", "intermediary"]).optional().nullable(),
      firmName: z.string().optional().nullable(),
      firmLicenseNo: z.string().optional().nullable(),
      supervisor: z.object({
        name: z.string().optional().nullable(),
        licenseNo: z.string().optional().nullable(),
      }),
      address: z.object({
        street: z.string().optional().nullable(),
        city: z.string().optional().nullable(),
        state: z.string().optional().nullable(),
        zip: z.string().optional().nullable(),
        phone: z.string().optional().nullable(),
      }),
    }),
    other: z.object({
      firmName: z.string().optional().nullable(),
      firmLicenseNo: z.string().optional().nullable(),
      represents: z.enum(["buyer_agent", "seller_subagent"]).optional().nullable(),
      associate: z.object({
        name: z.string().optional().nullable(),
        licenseNo: z.string().optional().nullable(),
        teamName: z.string().optional().nullable(),
        email: z.string().optional().nullable(),
        phone: z.string().optional().nullable(),
      }),
      supervisor: z.object({
        name: z.string().optional().nullable(),
        licenseNo: z.string().optional().nullable(),
      }),
      address: z.object({
        street: z.string().optional().nullable(),
        city: z.string().optional().nullable(),
        state: z.string().optional().nullable(),
        zip: z.string().optional().nullable(),
        phone: z.string().optional().nullable(),
      }),
    }),
    disclosure: z.object({
      fee: z.object({
        dollarAmount: z.string().optional().nullable(),
        percentage: z.string().optional().nullable(),
        type: z.enum(['dollar_amount', 'percentage']).optional().nullable(),
      }),
    }),
  }),
  closing: z.object({
    date: z.object({
      monthDay: z.string().optional().nullable(),
      year: z.string().optional().nullable(),
    }),
  }),
  possession: z.object({
    status: z.enum(['upon_closing', 'temporary_lease']).optional().nullable(),
  }),
  specialProvisions: z.object({
    text: z.string().optional().nullable(),
  }),
  settlement: z.object({
    sellerContributionToBrokerage: z.object({
      type: z.enum(['dollar_amount', 'percentage']).optional().nullable(),
      dollarAmount: z.string().optional().nullable(),
      percentage: z.string().optional().nullable(),
    }),
    sellerContributionToOther: z.object({
      amount: z.string().optional().nullable(),
    }),
  }),
  notices: z.object({
    buyer: z.object({
      contactInfo: z.object({
        part1: z.string().optional().nullable(),
        part2: z.string().optional().nullable(),
      }),
      phone: z.string().optional().nullable(),
      emailFax: z.object({
        '1': z.string().optional().nullable(),
        '2': z.string().optional().nullable(),
      }),
    }),
    seller: z.object({
      contactInfo: z.object({
        part1: z.string().optional().nullable(),
        part2: z.string().optional().nullable(),
      }),
      phone: z.string().optional().nullable(),
      emailFax: z.object({
        '1': z.string().optional().nullable(),
        '2': z.string().optional().nullable(),
      }),
    }),
  }),
  addenda: z.object({
    thirdPartyFinancing: z.boolean().optional(),
    sellerFinancing: z.boolean().optional(),
    hoa: z.boolean().optional(),
    buyersTemporaryLease: z.boolean().optional(),
    loanAssumption: z.boolean().optional(),
    saleOfOtherProperty: z.boolean().optional(),
    mineralReservation: z.boolean().optional(),
    backupContract: z.boolean().optional(),
    coastalAreaProperty: z.boolean().optional(),
    hydrostaticTesting: z.boolean().optional(),
    lenderAppraisalTermination: z.boolean().optional(),
    environmentalAssessment: z.boolean().optional(),
    sellersTemporaryLease: z.boolean().optional(),
    shortSale: z.boolean().optional(),
    seawardOfGulfWaterway: z.boolean().optional(),
    leadBasedPaint: z.boolean().optional(),
    propaneGasSystem: z.boolean().optional(),
    residentialLeases: z.boolean().optional(),
    fixtureLeases: z.boolean().optional(),
    section1031Exchange: z.boolean().optional(),
    improvementDistrict: z.boolean().optional(),
    otherText: z.object({
      p1: z.string().optional().nullable(),
    }),
  }),
  attorneys: z.object({
    buyer: z.object({
      name: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      fax: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
    }),
    seller: z.object({
      name: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      fax: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
    }),
  }),
  execution: z.object({
    day: z.string().optional().nullable(),
    month: z.string().optional().nullable(),
    year: z.string().optional().nullable(),
  }),
});

export type Trec14ContractData = z.infer<typeof Trec14Schema>;


================================================
FILE: lib/db/agents.md
================================================
# Lazily.AI: Database Module Agent Guide

This `AGENTS.md` governs all work within the `lib/db` directory. Adherence to these rules is critical for maintaining data integrity.

## 1. Core Responsibility

This module is the **single source of truth for the application's data layer**. It defines all tables, columns, and relations using the Drizzle ORM.

## 2. Schema & Migrations Workflow

* **The `schema.ts` file is the master blueprint.** All changes to the database structure **must** be made here first.
* After modifying `schema.ts`, you **must** generate a new migration file by running the following command in your terminal:
    ```bash
    pnpm db:generate
    ```
* To apply the new migration to your local database, run:
    ```bash
    pnpm db:migrate
    ```
* **NEVER manually edit the SQL files** inside the `migrations/` directory. They are managed automatically by Drizzle Kit.

## 3. Querying Best Practices

* **Do not write raw SQL.** Use the Drizzle ORM query syntax for all database interactions.
* If you need to fetch data for a common use case (e.g., getting all contracts for a user's team), **first check `queries.ts` for an existing function**.
* If a suitable query function does not exist, **create a new, reusable function in `queries.ts`**. Do not place one-off, complex queries directly inside server actions or API routes. This keeps our data access patterns clean and centralized.


================================================
FILE: lib/db/drizzle.ts
================================================
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';
import dotenv from 'dotenv';

dotenv.config();

if (!process.env.POSTGRES_URL) {
  throw new Error('POSTGRES_URL environment variable is not set');
}

export const client = postgres(process.env.POSTGRES_URL);
export const db = drizzle(client, { schema });



================================================
FILE: lib/db/queries.ts
================================================
// lib/db/queries.ts

import { desc, and, eq, isNull } from 'drizzle-orm';
import { db } from './drizzle';
// Import table objects (values)
import { activityLogs, teamMembers, teams, users, contracts, ActivityType, User } from './schema';
// Import TypeScript types separately for clarity
import type { Contract, Trec14ContractData } from './schema';
import { cookies } from 'next/headers';
import { verifyToken } from '@/lib/auth/session';

export async function getUser() {
  const sessionCookie = (await cookies()).get('session');
  if (!sessionCookie || !sessionCookie.value) {
    return null;
  }

  const sessionData = await verifyToken(sessionCookie.value);
  if (
    !sessionData ||
    !sessionData.user ||
    typeof sessionData.user.id !== 'number'
  ) {
    return null;
  }

  if (new Date(sessionData.expires) < new Date()) {
    return null;
  }

  const user = await db
    .select()
    .from(users)
    .where(and(eq(users.id, sessionData.user.id), isNull(users.deletedAt)))
    .limit(1);
  if (user.length === 0) {
    return null;
  }

  return user[0];
}

export async function getTeamByStripeCustomerId(customerId: string) {
  const result = await db
    .select()
    .from(teams)
    .where(eq(teams.stripeCustomerId, customerId))
    .limit(1);
  return result.length > 0 ? result[0] : null;
}

export async function updateTeamSubscription(
  teamId: number,
  subscriptionData: {
    stripeSubscriptionId: string | null;
    stripeProductId: string | null;
    planName: string | null;
    subscriptionStatus: string;
  }
) {
  await db
    .update(teams)
    .set({
      ...subscriptionData,
      updatedAt: new Date()
    })
    .where(eq(teams.id, teamId));
}

export async function getUserWithTeam(userId: number) {
  const result = await db
    .select({
      user: users,
      teamId: teamMembers.teamId,
      role: teamMembers.role,
    })
    .from(users)
    .leftJoin(teamMembers, eq(users.id, teamMembers.userId))
    .where(eq(users.id, userId))
    .limit(1);
  return result[0];
}

export async function getActivityLogs() {
  const user = await getUser();
  if (!user) {
    throw new Error('User not authenticated');
  }

  return await db
    .select({
      id: activityLogs.id,
      action: activityLogs.action,
      timestamp: activityLogs.timestamp,
      ipAddress: activityLogs.ipAddress,
      userName: users.name
    })
    .from(activityLogs)
    .leftJoin(users, eq(activityLogs.userId, users.id))
    .where(eq(activityLogs.userId, user.id))
    .orderBy(desc(activityLogs.timestamp))
    .limit(10);
}

export async function getTeamForUser() {
  const user = await getUser();
  if (!user) {
    return null;
  }

  const result = await db.query.teamMembers.findFirst({
    where: eq(teamMembers.userId, user.id),
    with: {
      team: {
        with: {
          teamMembers: {
            with: {
              user: {
                columns: {
                  id: true,
                  name: true,
                  email: true
                }
              }
            }
          }
        }
      }
    }
  });
  return result?.team || null;
}

// Fetches from the correct 'contracts' table
export async function getContractsForUser(): Promise<Contract[]> {
    const user = await getUser();
    if (!user) return [];
  
    const userWithTeam = await getUserWithTeam(user.id);
    if (!userWithTeam?.teamId) return [];
  
    try {
      const data = await db
        .select()
        .from(contracts)
        .where(eq(contracts.teamId, userWithTeam.teamId))
        .orderBy(desc(contracts.generatedAt));
      return data;
    } catch (error) {
      console.error('Database Error fetching contracts:', error);
      throw new Error('Failed to fetch contracts.');
    }
}

export async function createContract(teamId: number, userId: number, contractData: Trec14ContractData) {
    return await db.insert(contracts).values({
        teamId,
        userId,
        contractData,
    }).returning();
}

export async function getTeamOwner(teamId: number): Promise<User | null> {
  const result = await db
    .select({ user: users })
    .from(teamMembers)
    .innerJoin(users, eq(teamMembers.userId, users.id))
    .where(and(eq(teamMembers.teamId, teamId), eq(teamMembers.role, 'owner')))
    .limit(1);

  return result.length > 0 ? result[0].user : null;
}

export async function createActivityLog({
  teamId,
  userId,
  action,
  ipAddress,
}: {
  teamId: number;
  userId: number;
  action: ActivityType;
  ipAddress?: string;
}) {
  await db.insert(activityLogs).values({
    teamId,
    userId,
    action,
    ipAddress,
  });
}


================================================
FILE: lib/db/schema.ts
================================================
// lib/db/schema.ts

import {
  pgTable,
  serial,
  varchar,
  text,
  timestamp,
  integer,
  boolean,
  jsonb,
} from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 100 }),
  email: varchar('email', { length: 255 }).notNull().unique(),
  phone: varchar('phone', { length: 20 }),
  marketingEmailConsent: boolean('marketing_email_consent').default(false),
  marketingSmsConsent: boolean('marketing_sms_consent').default(false),
  passwordHash: text('password_hash').notNull(),
  role: varchar('role', { length: 20 }).notNull().default('member'),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
  deletedAt: timestamp('deleted_at'),
});

export const teams = pgTable('teams', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 100 }).notNull(),
  contractCredits: integer('contract_credits').notNull().default(0),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
  stripeCustomerId: text('stripe_customer_id').unique(),
  stripeSubscriptionId: text('stripe_subscription_id').unique(),
  stripeProductId: text('stripe_product_id'),
  planName: varchar('plan_name', { length: 50 }),
  subscriptionStatus: varchar('subscription_status', { length: 20 }),
});

export const owners = pgTable('owners', {
  id: serial('id').primaryKey(),
  teamId: integer('team_id').notNull().references(() => teams.id),
  fullName: varchar('full_name', { length: 255 }),
  mailingAddress: text('mailing_address'),
  createdAt: timestamp('created_at').notNull().defaultNow(),
});

export const properties = pgTable('properties', {
  id: serial('id').primaryKey(),
  teamId: integer('team_id').notNull().references(() => teams.id),
  ownerId: integer('owner_id').references(() => owners.id),
  streetAddress: varchar('street_address', { length: 255 }),
  city: varchar('city', { length: 100 }),
  zipCode: varchar('zip_code', { length: 20 }),
  offerPrice: varchar('offer_price', { length: 50 }),
  status: varchar('status', { length: 50 }).default('pending'),
  createdAt: timestamp('created_at').notNull().defaultNow(),
});

export const contracts = pgTable('contracts', {
    id: serial('id').primaryKey(),
    teamId: integer('team_id').notNull().references(() => teams.id),
    userId: integer('user_id').notNull().references(() => users.id),
    contractData: jsonb('contract_data').notNull(),
    status: varchar('status', { length: 50 }).default('pending_generation'),
    generatedAt: timestamp('generated_at').notNull().defaultNow(),
    filePath: text('file_path'),
});

export const creditPurchases = pgTable('credit_purchases', {
    id: serial('id').primaryKey(),
    teamId: integer('team_id').notNull().references(() => teams.id),
    creditsPurchased: integer('credits_purchased').notNull(),
    amountPaid: integer('amount_paid'),
    stripeCheckoutSessionId: text('stripe_checkout_session_id').notNull().unique(),
    createdAt: timestamp('created_at').notNull().defaultNow(),
});

export const teamMembers = pgTable('team_members', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull().references(() => users.id),
  teamId: integer('team_id').notNull().references(() => teams.id),
  role: varchar('role', { length: 50 }).notNull(),
  joinedAt: timestamp('joined_at').notNull().defaultNow(),
});

export const activityLogs = pgTable('activity_logs', {
  id: serial('id').primaryKey(),
  teamId: integer('team_id').notNull().references(() => teams.id),
  userId: integer('user_id').references(() => users.id),
  action: text('action').notNull(),
  timestamp: timestamp('timestamp').notNull().defaultNow(),
  ipAddress: varchar('ip_address', { length: 45 }),
});

export const invitations = pgTable('invitations', {
  id: serial('id').primaryKey(),
  teamId: integer('team_id').notNull().references(() => teams.id),
  email: varchar('email', { length: 255 }).notNull(),
  role: varchar('role', { length: 50 }).notNull(),
  invitedBy: integer('invited_by').notNull().references(() => users.id),
  invitedAt: timestamp('invited_at').notNull().defaultNow(),
  status: varchar('status', { length: 20 }).notNull().default('pending'),
});

// --- RELATIONS ---

export const teamsRelations = relations(teams, ({ many }) => ({
  teamMembers: many(teamMembers),
  activityLogs: many(activityLogs),
  invitations: many(invitations),
  properties: many(properties),
  owners: many(owners),
  contracts: many(contracts),
  creditPurchases: many(creditPurchases),
}));

export const usersRelations = relations(users, ({ many }) => ({
  teamMembers: many(teamMembers),
  invitationsSent: many(invitations),
  contracts: many(contracts),
}));

export const ownersRelations = relations(owners, ({ one, many }) => ({
  team: one(teams, { fields: [owners.teamId], references: [teams.id] }),
  properties: many(properties),
}));

export const propertiesRelations = relations(properties, ({ one }) => ({
  team: one(teams, { fields: [properties.teamId], references: [teams.id] }),
  owner: one(owners, { fields: [properties.ownerId], references: [owners.id] }),
}));

// --- THIS IS THE CORRECTED SECTION ---
export const contractsRelations = relations(contracts, ({ one }) => ({
  team: one(teams, { fields: [contracts.teamId], references: [teams.id] }),
  user: one(users, { fields: [contracts.userId], references: [users.id] }),
}));
// --- END OF CORRECTED SECTION ---

export const creditPurchasesRelations = relations(creditPurchases, ({ one }) => ({
    team: one(teams, {
      fields: [creditPurchases.teamId],
      references: [teams.id],
    }),
}));

export const invitationsRelations = relations(invitations, ({ one }) => ({
  team: one(teams, { fields: [invitations.teamId], references: [teams.id] }),
  invitedBy: one(users, { fields: [invitations.invitedBy], references: [users.id] }),
}));

export const teamMembersRelations = relations(teamMembers, ({ one }) => ({
  user: one(users, { fields: [teamMembers.userId], references: [users.id] }),
  team: one(teams, { fields: [teamMembers.teamId], references: [teams.id] }),
}));

export const activityLogsRelations = relations(activityLogs, ({ one }) => ({
  team: one(teams, { fields: [activityLogs.teamId], references: [teams.id] }),
  user: one(users, { fields: [activityLogs.userId], references: [users.id] }),
}));

// --- TYPES ---
// (No changes in this section)

export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Team = typeof teams.$inferSelect;
export type NewTeam = typeof teams.$inferInsert;
export type Property = typeof properties.$inferSelect;
export type NewProperty = typeof properties.$inferInsert;
export type Owner = typeof owners.$inferSelect;
export type NewOwner = typeof owners.$inferInsert;
export type Contract = typeof contracts.$inferSelect;
export type NewContract = typeof contracts.$inferInsert;
export type Trec14ContractData = any; // Placeholder until we can import from validation.ts
export type CreditPurchase = typeof creditPurchases.$inferSelect;
export type NewCreditPurchase = typeof creditPurchases.$inferInsert;
export type TeamMember = typeof teamMembers.$inferSelect;
export type NewTeamMember = typeof teamMembers.$inferInsert;
export type ActivityLog = typeof activityLogs.$inferSelect;
export type NewActivityLog = typeof activityLogs.$inferInsert;
export type Invitation = typeof invitations.$inferSelect;
export type NewInvitation = typeof invitations.$inferInsert;
export type TeamDataWithMembers = Team & {
  teamMembers: (TeamMember & {
    user: Pick<User, 'id' | 'name' | 'email'>;
  })[];
};

export enum ActivityType {
  SIGN_UP = 'SIGN_UP',
  SIGN_IN = 'SIGN_IN',
  SIGN_OUT = 'SIGN_OUT',
  UPDATE_PASSWORD = 'UPDATE_PASSWORD',
  DELETE_ACCOUNT = 'DELETE_ACCOUNT',
  UPDATE_ACCOUNT = 'UPDATE_ACCOUNT',
  CREATE_TEAM = 'CREATE_TEAM',
  REMOVE_TEAM_MEMBER = 'REMOVE_TEAM_MEMBER',
  INVITE_TEAM_MEMBER = 'INVITE_TEAM_MEMBER',
  ACCEPT_INVITATION = 'ACCEPT_INVITATION',
  MEMBERSHIP_PURCHASE = 'MEMBERSHIP_PURCHASE',
  MEMBERSHIP_RENEWAL = 'MEMBERSHIP_RENEWAL',
  CREDIT_PURCHASE = 'CREDIT_PURCHASE',
  CONTRACT_GENERATED = 'CONTRACT_GENERATED',
}


================================================
FILE: lib/db/seed.ts
================================================
import { stripe } from '../payments/stripe';
import { db } from './drizzle';
import { users, teams, teamMembers } from './schema';
import { hashPassword } from '@/lib/auth/session';

async function createStripeProducts() {
  console.log('Creating Stripe products and prices...');

  const baseProduct = await stripe.products.create({
    name: 'Base',
    description: 'Base subscription plan',
  });

  await stripe.prices.create({
    product: baseProduct.id,
    unit_amount: 800, // $8 in cents
    currency: 'usd',
    recurring: {
      interval: 'month',
      trial_period_days: 7,
    },
  });

  const plusProduct = await stripe.products.create({
    name: 'Plus',
    description: 'Plus subscription plan',
  });

  await stripe.prices.create({
    product: plusProduct.id,
    unit_amount: 1200, // $12 in cents
    currency: 'usd',
    recurring: {
      interval: 'month',
      trial_period_days: 7,
    },
  });

  console.log('Stripe products and prices created successfully.');
}

async function seed() {
  const email = 'test@test.com';
  const password = 'admin123';
  const passwordHash = await hashPassword(password);

  const [user] = await db
    .insert(users)
    .values([
      {
        email: email,
        passwordHash: passwordHash,
        role: "owner",
      },
    ])
    .returning();

  console.log('Initial user created.');

  const [team] = await db
    .insert(teams)
    .values({
      name: 'Test Team',
    })
    .returning();

  await db.insert(teamMembers).values({
    teamId: team.id,
    userId: user.id,
    role: 'owner',
  });

  await createStripeProducts();
}

seed()
  .catch((error) => {
    console.error('Seed process failed:', error);
    process.exit(1);
  })
  .finally(() => {
    console.log('Seed process finished. Exiting...');
    process.exit(0);
  });



================================================
FILE: lib/db/setup.ts
================================================
import { exec } from 'node:child_process';
import { promises as fs } from 'node:fs';
import { promisify } from 'node:util';
import readline from 'node:readline';
import crypto from 'node:crypto';
import path from 'node:path';
import os from 'node:os';

const execAsync = promisify(exec);

function question(query: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) =>
    rl.question(query, (ans) => {
      rl.close();
      resolve(ans);
    })
  );
}

async function checkStripeCLI() {
  console.log(
    'Step 1: Checking if Stripe CLI is installed and authenticated...'
  );
  try {
    await execAsync('stripe --version');
    console.log('Stripe CLI is installed.');

    // Check if Stripe CLI is authenticated
    try {
      await execAsync('stripe config --list');
      console.log('Stripe CLI is authenticated.');
    } catch (error) {
      console.log(
        'Stripe CLI is not authenticated or the authentication has expired.'
      );
      console.log('Please run: stripe login');
      const answer = await question(
        'Have you completed the authentication? (y/n): '
      );
      if (answer.toLowerCase() !== 'y') {
        console.log(
          'Please authenticate with Stripe CLI and run this script again.'
        );
        process.exit(1);
      }

      // Verify authentication after user confirms login
      try {
        await execAsync('stripe config --list');
        console.log('Stripe CLI authentication confirmed.');
      } catch (error) {
        console.error(
          'Failed to verify Stripe CLI authentication. Please try again.'
        );
        process.exit(1);
      }
    }
  } catch (error) {
    console.error(
      'Stripe CLI is not installed. Please install it and try again.'
    );
    console.log('To install Stripe CLI, follow these steps:');
    console.log('1. Visit: https://docs.stripe.com/stripe-cli');
    console.log(
      '2. Download and install the Stripe CLI for your operating system'
    );
    console.log('3. After installation, run: stripe login');
    console.log(
      'After installation and authentication, please run this setup script again.'
    );
    process.exit(1);
  }
}

async function getPostgresURL(): Promise<string> {
  console.log('Step 2: Setting up Postgres');
  const dbChoice = await question(
    'Do you want to use a local Postgres instance with Docker (L) or a remote Postgres instance (R)? (L/R): '
  );

  if (dbChoice.toLowerCase() === 'l') {
    console.log('Setting up local Postgres instance with Docker...');
    await setupLocalPostgres();
    return 'postgres://postgres:postgres@localhost:54322/postgres';
  } else {
    console.log(
      'You can find Postgres databases at: https://vercel.com/marketplace?category=databases'
    );
    return await question('Enter your POSTGRES_URL: ');
  }
}

async function setupLocalPostgres() {
  console.log('Checking if Docker is installed...');
  try {
    await execAsync('docker --version');
    console.log('Docker is installed.');
  } catch (error) {
    console.error(
      'Docker is not installed. Please install Docker and try again.'
    );
    console.log(
      'To install Docker, visit: https://docs.docker.com/get-docker/'
    );
    process.exit(1);
  }

  console.log('Creating docker-compose.yml file...');
  const dockerComposeContent = `
services:
  postgres:
    image: postgres:16.4-alpine
    container_name: next_saas_starter_postgres
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "54322:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
`;

  await fs.writeFile(
    path.join(process.cwd(), 'docker-compose.yml'),
    dockerComposeContent
  );
  console.log('docker-compose.yml file created.');

  console.log('Starting Docker container with `docker compose up -d`...');
  try {
    await execAsync('docker compose up -d');
    console.log('Docker container started successfully.');
  } catch (error) {
    console.error(
      'Failed to start Docker container. Please check your Docker installation and try again.'
    );
    process.exit(1);
  }
}

async function getStripeSecretKey(): Promise<string> {
  console.log('Step 3: Getting Stripe Secret Key');
  console.log(
    'You can find your Stripe Secret Key at: https://dashboard.stripe.com/test/apikeys'
  );
  return await question('Enter your Stripe Secret Key: ');
}

async function createStripeWebhook(): Promise<string> {
  console.log('Step 4: Creating Stripe webhook...');
  try {
    const { stdout } = await execAsync('stripe listen --print-secret');
    const match = stdout.match(/whsec_[a-zA-Z0-9]+/);
    if (!match) {
      throw new Error('Failed to extract Stripe webhook secret');
    }
    console.log('Stripe webhook created.');
    return match[0];
  } catch (error) {
    console.error(
      'Failed to create Stripe webhook. Check your Stripe CLI installation and permissions.'
    );
    if (os.platform() === 'win32') {
      console.log(
        'Note: On Windows, you may need to run this script as an administrator.'
      );
    }
    throw error;
  }
}

function generateAuthSecret(): string {
  console.log('Step 5: Generating AUTH_SECRET...');
  return crypto.randomBytes(32).toString('hex');
}

async function writeEnvFile(envVars: Record<string, string>) {
  console.log('Step 6: Writing environment variables to .env');
  const envContent = Object.entries(envVars)
    .map(([key, value]) => `${key}=${value}`)
    .join('\n');

  await fs.writeFile(path.join(process.cwd(), '.env'), envContent);
  console.log('.env file created with the necessary variables.');
}

async function main() {
  await checkStripeCLI();

  const POSTGRES_URL = await getPostgresURL();
  const STRIPE_SECRET_KEY = await getStripeSecretKey();
  const STRIPE_WEBHOOK_SECRET = await createStripeWebhook();
  const BASE_URL = 'http://localhost:3000';
  const AUTH_SECRET = generateAuthSecret();

  await writeEnvFile({
    POSTGRES_URL,
    STRIPE_SECRET_KEY,
    STRIPE_WEBHOOK_SECRET,
    BASE_URL,
    AUTH_SECRET,
  });

  console.log('ðŸŽ‰ Setup completed successfully!');
}

main().catch(console.error);



================================================
FILE: lib/db/migrations/0000_soft_the_anarchist.sql
================================================
CREATE TABLE IF NOT EXISTS "activity_logs" (
	"id" serial PRIMARY KEY NOT NULL,
	"team_id" integer NOT NULL,
	"user_id" integer,
	"action" text NOT NULL,
	"timestamp" timestamp DEFAULT now() NOT NULL,
	"ip_address" varchar(45)
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "invitations" (
	"id" serial PRIMARY KEY NOT NULL,
	"team_id" integer NOT NULL,
	"email" varchar(255) NOT NULL,
	"role" varchar(50) NOT NULL,
	"invited_by" integer NOT NULL,
	"invited_at" timestamp DEFAULT now() NOT NULL,
	"status" varchar(20) DEFAULT 'pending' NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "team_members" (
	"id" serial PRIMARY KEY NOT NULL,
	"user_id" integer NOT NULL,
	"team_id" integer NOT NULL,
	"role" varchar(50) NOT NULL,
	"joined_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "teams" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" varchar(100) NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	"stripe_customer_id" text,
	"stripe_subscription_id" text,
	"stripe_product_id" text,
	"plan_name" varchar(50),
	"subscription_status" varchar(20),
	CONSTRAINT "teams_stripe_customer_id_unique" UNIQUE("stripe_customer_id"),
	CONSTRAINT "teams_stripe_subscription_id_unique" UNIQUE("stripe_subscription_id")
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "users" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" varchar(100),
	"email" varchar(255) NOT NULL,
	"password_hash" text NOT NULL,
	"role" varchar(20) DEFAULT 'member' NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL,
	"deleted_at" timestamp,
	CONSTRAINT "users_email_unique" UNIQUE("email")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "activity_logs" ADD CONSTRAINT "activity_logs_team_id_teams_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "activity_logs" ADD CONSTRAINT "activity_logs_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "invitations" ADD CONSTRAINT "invitations_team_id_teams_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "invitations" ADD CONSTRAINT "invitations_invited_by_users_id_fk" FOREIGN KEY ("invited_by") REFERENCES "public"."users"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "team_members" ADD CONSTRAINT "team_members_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "team_members" ADD CONSTRAINT "team_members_team_id_teams_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE no action ON UPDATE no action;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;



================================================
FILE: lib/db/migrations/0001_mixed_lilith.sql
================================================
CREATE TABLE "contracts" (
	"id" serial PRIMARY KEY NOT NULL,
	"team_id" integer NOT NULL,
	"user_id" integer NOT NULL,
	"property_id" integer,
	"generated_at" timestamp DEFAULT now() NOT NULL,
	"file_path" text
);
--> statement-breakpoint
CREATE TABLE "owners" (
	"id" serial PRIMARY KEY NOT NULL,
	"team_id" integer NOT NULL,
	"full_name" varchar(255),
	"mailing_address" text,
	"created_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
CREATE TABLE "properties" (
	"id" serial PRIMARY KEY NOT NULL,
	"team_id" integer NOT NULL,
	"owner_id" integer,
	"street_address" varchar(255),
	"city" varchar(100),
	"zip_code" varchar(20),
	"offer_price" varchar(50),
	"status" varchar(50) DEFAULT 'pending',
	"created_at" timestamp DEFAULT now() NOT NULL
);
--> statement-breakpoint
ALTER TABLE "teams" ADD COLUMN "contract_credits" integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE "users" ADD COLUMN "phone" varchar(20);--> statement-breakpoint
ALTER TABLE "users" ADD COLUMN "marketing_email_consent" boolean DEFAULT false;--> statement-breakpoint
ALTER TABLE "users" ADD COLUMN "marketing_sms_consent" boolean DEFAULT false;--> statement-breakpoint
ALTER TABLE "contracts" ADD CONSTRAINT "contracts_team_id_teams_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "contracts" ADD CONSTRAINT "contracts_user_id_users_id_fk" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "contracts" ADD CONSTRAINT "contracts_property_id_properties_id_fk" FOREIGN KEY ("property_id") REFERENCES "public"."properties"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "owners" ADD CONSTRAINT "owners_team_id_teams_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "properties" ADD CONSTRAINT "properties_team_id_teams_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "properties" ADD CONSTRAINT "properties_owner_id_owners_id_fk" FOREIGN KEY ("owner_id") REFERENCES "public"."owners"("id") ON DELETE no action ON UPDATE no action;


================================================
FILE: lib/db/migrations/0002_regular_madelyne_pryor.sql
================================================
ALTER TABLE "properties" ADD COLUMN "lot" varchar(100);--> statement-breakpoint
ALTER TABLE "properties" ADD COLUMN "block" varchar(100);--> statement-breakpoint
ALTER TABLE "properties" ADD COLUMN "addition" varchar(255);--> statement-breakpoint
ALTER TABLE "properties" ADD COLUMN "county" varchar(100);


================================================
FILE: lib/db/migrations/0003_tidy_omega_flight.sql
================================================
CREATE TABLE "credit_purchases" (
	"id" serial PRIMARY KEY NOT NULL,
	"team_id" integer NOT NULL,
	"credits_purchased" integer NOT NULL,
	"amount_paid" integer,
	"stripe_checkout_session_id" text NOT NULL,
	"created_at" timestamp DEFAULT now() NOT NULL,
	CONSTRAINT "credit_purchases_stripe_checkout_session_id_unique" UNIQUE("stripe_checkout_session_id")
);
--> statement-breakpoint
ALTER TABLE "credit_purchases" ADD CONSTRAINT "credit_purchases_team_id_teams_id_fk" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "properties" DROP COLUMN "lot";--> statement-breakpoint
ALTER TABLE "properties" DROP COLUMN "block";--> statement-breakpoint
ALTER TABLE "properties" DROP COLUMN "addition";--> statement-breakpoint
ALTER TABLE "properties" DROP COLUMN "county";


================================================
FILE: lib/db/migrations/0004_lonely_lethal_legion.sql
================================================
ALTER TABLE "contracts" DROP CONSTRAINT "contracts_property_id_properties_id_fk";
--> statement-breakpoint
ALTER TABLE "contracts" ADD COLUMN "contract_data" jsonb NOT NULL;--> statement-breakpoint
ALTER TABLE "contracts" ADD COLUMN "status" varchar(50) DEFAULT 'pending_generation';--> statement-breakpoint
ALTER TABLE "contracts" DROP COLUMN "property_id";


================================================
FILE: lib/db/migrations/meta/0000_snapshot.json
================================================
{
  "id": "261fd993-fb2c-43e7-89d6-cd58786c5f58",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.activity_logs": {
      "name": "activity_logs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "action": {
          "name": "action",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "activity_logs_team_id_teams_id_fk": {
          "name": "activity_logs_team_id_teams_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "activity_logs_user_id_users_id_fk": {
          "name": "activity_logs_user_id_users_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "public.invitations": {
      "name": "invitations",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "invited_by": {
          "name": "invited_by",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "invited_at": {
          "name": "invited_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "status": {
          "name": "status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "invitations_team_id_teams_id_fk": {
          "name": "invitations_team_id_teams_id_fk",
          "tableFrom": "invitations",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "invitations_invited_by_users_id_fk": {
          "name": "invitations_invited_by_users_id_fk",
          "tableFrom": "invitations",
          "tableTo": "users",
          "columnsFrom": [
            "invited_by"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "public.team_members": {
      "name": "team_members",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "joined_at": {
          "name": "joined_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "team_members_user_id_users_id_fk": {
          "name": "team_members_user_id_users_id_fk",
          "tableFrom": "team_members",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_members_team_id_teams_id_fk": {
          "name": "team_members_team_id_teams_id_fk",
          "tableFrom": "team_members",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "public.teams": {
      "name": "teams",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_subscription_id": {
          "name": "stripe_subscription_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_product_id": {
          "name": "stripe_product_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "plan_name": {
          "name": "plan_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "subscription_status": {
          "name": "subscription_status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "teams_stripe_customer_id_unique": {
          "name": "teams_stripe_customer_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_customer_id"
          ]
        },
        "teams_stripe_subscription_id_unique": {
          "name": "teams_stripe_subscription_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_subscription_id"
          ]
        }
      }
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "password_hash": {
          "name": "password_hash",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'member'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "deleted_at": {
          "name": "deleted_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      }
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
FILE: lib/db/migrations/meta/0001_snapshot.json
================================================
{
  "id": "40ba496d-b42d-4917-ba19-7963907407f8",
  "prevId": "261fd993-fb2c-43e7-89d6-cd58786c5f58",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.activity_logs": {
      "name": "activity_logs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "action": {
          "name": "action",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "activity_logs_team_id_teams_id_fk": {
          "name": "activity_logs_team_id_teams_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "activity_logs_user_id_users_id_fk": {
          "name": "activity_logs_user_id_users_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contracts": {
      "name": "contracts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "property_id": {
          "name": "property_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "generated_at": {
          "name": "generated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "file_path": {
          "name": "file_path",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contracts_team_id_teams_id_fk": {
          "name": "contracts_team_id_teams_id_fk",
          "tableFrom": "contracts",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "contracts_user_id_users_id_fk": {
          "name": "contracts_user_id_users_id_fk",
          "tableFrom": "contracts",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "contracts_property_id_properties_id_fk": {
          "name": "contracts_property_id_properties_id_fk",
          "tableFrom": "contracts",
          "tableTo": "properties",
          "columnsFrom": [
            "property_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.invitations": {
      "name": "invitations",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "invited_by": {
          "name": "invited_by",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "invited_at": {
          "name": "invited_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "status": {
          "name": "status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "invitations_team_id_teams_id_fk": {
          "name": "invitations_team_id_teams_id_fk",
          "tableFrom": "invitations",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "invitations_invited_by_users_id_fk": {
          "name": "invitations_invited_by_users_id_fk",
          "tableFrom": "invitations",
          "tableTo": "users",
          "columnsFrom": [
            "invited_by"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.owners": {
      "name": "owners",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "full_name": {
          "name": "full_name",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "mailing_address": {
          "name": "mailing_address",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "owners_team_id_teams_id_fk": {
          "name": "owners_team_id_teams_id_fk",
          "tableFrom": "owners",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.properties": {
      "name": "properties",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "owner_id": {
          "name": "owner_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "street_address": {
          "name": "street_address",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "city": {
          "name": "city",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "zip_code": {
          "name": "zip_code",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "offer_price": {
          "name": "offer_price",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false,
          "default": "'pending'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "properties_team_id_teams_id_fk": {
          "name": "properties_team_id_teams_id_fk",
          "tableFrom": "properties",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "properties_owner_id_owners_id_fk": {
          "name": "properties_owner_id_owners_id_fk",
          "tableFrom": "properties",
          "tableTo": "owners",
          "columnsFrom": [
            "owner_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.team_members": {
      "name": "team_members",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "joined_at": {
          "name": "joined_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "team_members_user_id_users_id_fk": {
          "name": "team_members_user_id_users_id_fk",
          "tableFrom": "team_members",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_members_team_id_teams_id_fk": {
          "name": "team_members_team_id_teams_id_fk",
          "tableFrom": "team_members",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.teams": {
      "name": "teams",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "contract_credits": {
          "name": "contract_credits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "default": 0
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_subscription_id": {
          "name": "stripe_subscription_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_product_id": {
          "name": "stripe_product_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "plan_name": {
          "name": "plan_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "subscription_status": {
          "name": "subscription_status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "teams_stripe_customer_id_unique": {
          "name": "teams_stripe_customer_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_customer_id"
          ]
        },
        "teams_stripe_subscription_id_unique": {
          "name": "teams_stripe_subscription_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_subscription_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "phone": {
          "name": "phone",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "marketing_email_consent": {
          "name": "marketing_email_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "marketing_sms_consent": {
          "name": "marketing_sms_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "password_hash": {
          "name": "password_hash",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'member'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "deleted_at": {
          "name": "deleted_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
FILE: lib/db/migrations/meta/0002_snapshot.json
================================================
{
  "id": "1d16a545-7536-44b8-ba58-263af6dec5e1",
  "prevId": "40ba496d-b42d-4917-ba19-7963907407f8",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.activity_logs": {
      "name": "activity_logs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "action": {
          "name": "action",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "activity_logs_team_id_teams_id_fk": {
          "name": "activity_logs_team_id_teams_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "activity_logs_user_id_users_id_fk": {
          "name": "activity_logs_user_id_users_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contracts": {
      "name": "contracts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "property_id": {
          "name": "property_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "generated_at": {
          "name": "generated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "file_path": {
          "name": "file_path",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contracts_team_id_teams_id_fk": {
          "name": "contracts_team_id_teams_id_fk",
          "tableFrom": "contracts",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "contracts_user_id_users_id_fk": {
          "name": "contracts_user_id_users_id_fk",
          "tableFrom": "contracts",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "contracts_property_id_properties_id_fk": {
          "name": "contracts_property_id_properties_id_fk",
          "tableFrom": "contracts",
          "tableTo": "properties",
          "columnsFrom": [
            "property_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.invitations": {
      "name": "invitations",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "invited_by": {
          "name": "invited_by",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "invited_at": {
          "name": "invited_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "status": {
          "name": "status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "invitations_team_id_teams_id_fk": {
          "name": "invitations_team_id_teams_id_fk",
          "tableFrom": "invitations",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "invitations_invited_by_users_id_fk": {
          "name": "invitations_invited_by_users_id_fk",
          "tableFrom": "invitations",
          "tableTo": "users",
          "columnsFrom": [
            "invited_by"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.owners": {
      "name": "owners",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "full_name": {
          "name": "full_name",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "mailing_address": {
          "name": "mailing_address",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "owners_team_id_teams_id_fk": {
          "name": "owners_team_id_teams_id_fk",
          "tableFrom": "owners",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.properties": {
      "name": "properties",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "owner_id": {
          "name": "owner_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "street_address": {
          "name": "street_address",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "city": {
          "name": "city",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "zip_code": {
          "name": "zip_code",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "lot": {
          "name": "lot",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "block": {
          "name": "block",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "addition": {
          "name": "addition",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "county": {
          "name": "county",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "offer_price": {
          "name": "offer_price",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false,
          "default": "'pending'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "properties_team_id_teams_id_fk": {
          "name": "properties_team_id_teams_id_fk",
          "tableFrom": "properties",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "properties_owner_id_owners_id_fk": {
          "name": "properties_owner_id_owners_id_fk",
          "tableFrom": "properties",
          "tableTo": "owners",
          "columnsFrom": [
            "owner_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.team_members": {
      "name": "team_members",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "joined_at": {
          "name": "joined_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "team_members_user_id_users_id_fk": {
          "name": "team_members_user_id_users_id_fk",
          "tableFrom": "team_members",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_members_team_id_teams_id_fk": {
          "name": "team_members_team_id_teams_id_fk",
          "tableFrom": "team_members",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.teams": {
      "name": "teams",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "contract_credits": {
          "name": "contract_credits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "default": 0
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_subscription_id": {
          "name": "stripe_subscription_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_product_id": {
          "name": "stripe_product_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "plan_name": {
          "name": "plan_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "subscription_status": {
          "name": "subscription_status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "teams_stripe_customer_id_unique": {
          "name": "teams_stripe_customer_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_customer_id"
          ]
        },
        "teams_stripe_subscription_id_unique": {
          "name": "teams_stripe_subscription_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_subscription_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "phone": {
          "name": "phone",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "marketing_email_consent": {
          "name": "marketing_email_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "marketing_sms_consent": {
          "name": "marketing_sms_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "password_hash": {
          "name": "password_hash",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'member'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "deleted_at": {
          "name": "deleted_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
FILE: lib/db/migrations/meta/0003_snapshot.json
================================================
{
  "id": "2a57b7b9-5d88-4f06-8449-e0ec984c43ee",
  "prevId": "1d16a545-7536-44b8-ba58-263af6dec5e1",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.activity_logs": {
      "name": "activity_logs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "action": {
          "name": "action",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "activity_logs_team_id_teams_id_fk": {
          "name": "activity_logs_team_id_teams_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "activity_logs_user_id_users_id_fk": {
          "name": "activity_logs_user_id_users_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contracts": {
      "name": "contracts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "property_id": {
          "name": "property_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "generated_at": {
          "name": "generated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "file_path": {
          "name": "file_path",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contracts_team_id_teams_id_fk": {
          "name": "contracts_team_id_teams_id_fk",
          "tableFrom": "contracts",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "contracts_user_id_users_id_fk": {
          "name": "contracts_user_id_users_id_fk",
          "tableFrom": "contracts",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "contracts_property_id_properties_id_fk": {
          "name": "contracts_property_id_properties_id_fk",
          "tableFrom": "contracts",
          "tableTo": "properties",
          "columnsFrom": [
            "property_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.credit_purchases": {
      "name": "credit_purchases",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "credits_purchased": {
          "name": "credits_purchased",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "amount_paid": {
          "name": "amount_paid",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_checkout_session_id": {
          "name": "stripe_checkout_session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "credit_purchases_team_id_teams_id_fk": {
          "name": "credit_purchases_team_id_teams_id_fk",
          "tableFrom": "credit_purchases",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "credit_purchases_stripe_checkout_session_id_unique": {
          "name": "credit_purchases_stripe_checkout_session_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_checkout_session_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.invitations": {
      "name": "invitations",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "invited_by": {
          "name": "invited_by",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "invited_at": {
          "name": "invited_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "status": {
          "name": "status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "invitations_team_id_teams_id_fk": {
          "name": "invitations_team_id_teams_id_fk",
          "tableFrom": "invitations",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "invitations_invited_by_users_id_fk": {
          "name": "invitations_invited_by_users_id_fk",
          "tableFrom": "invitations",
          "tableTo": "users",
          "columnsFrom": [
            "invited_by"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.owners": {
      "name": "owners",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "full_name": {
          "name": "full_name",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "mailing_address": {
          "name": "mailing_address",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "owners_team_id_teams_id_fk": {
          "name": "owners_team_id_teams_id_fk",
          "tableFrom": "owners",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.properties": {
      "name": "properties",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "owner_id": {
          "name": "owner_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "street_address": {
          "name": "street_address",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "city": {
          "name": "city",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "zip_code": {
          "name": "zip_code",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "offer_price": {
          "name": "offer_price",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false,
          "default": "'pending'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "properties_team_id_teams_id_fk": {
          "name": "properties_team_id_teams_id_fk",
          "tableFrom": "properties",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "properties_owner_id_owners_id_fk": {
          "name": "properties_owner_id_owners_id_fk",
          "tableFrom": "properties",
          "tableTo": "owners",
          "columnsFrom": [
            "owner_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.team_members": {
      "name": "team_members",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "joined_at": {
          "name": "joined_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "team_members_user_id_users_id_fk": {
          "name": "team_members_user_id_users_id_fk",
          "tableFrom": "team_members",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_members_team_id_teams_id_fk": {
          "name": "team_members_team_id_teams_id_fk",
          "tableFrom": "team_members",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.teams": {
      "name": "teams",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "contract_credits": {
          "name": "contract_credits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "default": 0
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_subscription_id": {
          "name": "stripe_subscription_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_product_id": {
          "name": "stripe_product_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "plan_name": {
          "name": "plan_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "subscription_status": {
          "name": "subscription_status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "teams_stripe_customer_id_unique": {
          "name": "teams_stripe_customer_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_customer_id"
          ]
        },
        "teams_stripe_subscription_id_unique": {
          "name": "teams_stripe_subscription_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_subscription_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "phone": {
          "name": "phone",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "marketing_email_consent": {
          "name": "marketing_email_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "marketing_sms_consent": {
          "name": "marketing_sms_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "password_hash": {
          "name": "password_hash",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'member'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "deleted_at": {
          "name": "deleted_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
FILE: lib/db/migrations/meta/0004_snapshot.json
================================================
{
  "id": "32e52569-5b24-4b1b-a21e-fb0afe441aef",
  "prevId": "2a57b7b9-5d88-4f06-8449-e0ec984c43ee",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.activity_logs": {
      "name": "activity_logs",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "action": {
          "name": "action",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "timestamp": {
          "name": "timestamp",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "ip_address": {
          "name": "ip_address",
          "type": "varchar(45)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "activity_logs_team_id_teams_id_fk": {
          "name": "activity_logs_team_id_teams_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "activity_logs_user_id_users_id_fk": {
          "name": "activity_logs_user_id_users_id_fk",
          "tableFrom": "activity_logs",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.contracts": {
      "name": "contracts",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "contract_data": {
          "name": "contract_data",
          "type": "jsonb",
          "primaryKey": false,
          "notNull": true
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false,
          "default": "'pending_generation'"
        },
        "generated_at": {
          "name": "generated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "file_path": {
          "name": "file_path",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "contracts_team_id_teams_id_fk": {
          "name": "contracts_team_id_teams_id_fk",
          "tableFrom": "contracts",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "contracts_user_id_users_id_fk": {
          "name": "contracts_user_id_users_id_fk",
          "tableFrom": "contracts",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.credit_purchases": {
      "name": "credit_purchases",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "credits_purchased": {
          "name": "credits_purchased",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "amount_paid": {
          "name": "amount_paid",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_checkout_session_id": {
          "name": "stripe_checkout_session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "credit_purchases_team_id_teams_id_fk": {
          "name": "credit_purchases_team_id_teams_id_fk",
          "tableFrom": "credit_purchases",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "credit_purchases_stripe_checkout_session_id_unique": {
          "name": "credit_purchases_stripe_checkout_session_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_checkout_session_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.invitations": {
      "name": "invitations",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "invited_by": {
          "name": "invited_by",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "invited_at": {
          "name": "invited_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "status": {
          "name": "status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'pending'"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "invitations_team_id_teams_id_fk": {
          "name": "invitations_team_id_teams_id_fk",
          "tableFrom": "invitations",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "invitations_invited_by_users_id_fk": {
          "name": "invitations_invited_by_users_id_fk",
          "tableFrom": "invitations",
          "tableTo": "users",
          "columnsFrom": [
            "invited_by"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.owners": {
      "name": "owners",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "full_name": {
          "name": "full_name",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "mailing_address": {
          "name": "mailing_address",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "owners_team_id_teams_id_fk": {
          "name": "owners_team_id_teams_id_fk",
          "tableFrom": "owners",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.properties": {
      "name": "properties",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "owner_id": {
          "name": "owner_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": false
        },
        "street_address": {
          "name": "street_address",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": false
        },
        "city": {
          "name": "city",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "zip_code": {
          "name": "zip_code",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "offer_price": {
          "name": "offer_price",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "status": {
          "name": "status",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false,
          "default": "'pending'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "properties_team_id_teams_id_fk": {
          "name": "properties_team_id_teams_id_fk",
          "tableFrom": "properties",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "properties_owner_id_owners_id_fk": {
          "name": "properties_owner_id_owners_id_fk",
          "tableFrom": "properties",
          "tableTo": "owners",
          "columnsFrom": [
            "owner_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.team_members": {
      "name": "team_members",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "user_id": {
          "name": "user_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "team_id": {
          "name": "team_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": true
        },
        "joined_at": {
          "name": "joined_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {
        "team_members_user_id_users_id_fk": {
          "name": "team_members_user_id_users_id_fk",
          "tableFrom": "team_members",
          "tableTo": "users",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_members_team_id_teams_id_fk": {
          "name": "team_members_team_id_teams_id_fk",
          "tableFrom": "team_members",
          "tableTo": "teams",
          "columnsFrom": [
            "team_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.teams": {
      "name": "teams",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": true
        },
        "contract_credits": {
          "name": "contract_credits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "default": 0
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_subscription_id": {
          "name": "stripe_subscription_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_product_id": {
          "name": "stripe_product_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "plan_name": {
          "name": "plan_name",
          "type": "varchar(50)",
          "primaryKey": false,
          "notNull": false
        },
        "subscription_status": {
          "name": "subscription_status",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "teams_stripe_customer_id_unique": {
          "name": "teams_stripe_customer_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_customer_id"
          ]
        },
        "teams_stripe_subscription_id_unique": {
          "name": "teams_stripe_subscription_id_unique",
          "nullsNotDistinct": false,
          "columns": [
            "stripe_subscription_id"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    },
    "public.users": {
      "name": "users",
      "schema": "",
      "columns": {
        "id": {
          "name": "id",
          "type": "serial",
          "primaryKey": true,
          "notNull": true
        },
        "name": {
          "name": "name",
          "type": "varchar(100)",
          "primaryKey": false,
          "notNull": false
        },
        "email": {
          "name": "email",
          "type": "varchar(255)",
          "primaryKey": false,
          "notNull": true
        },
        "phone": {
          "name": "phone",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": false
        },
        "marketing_email_consent": {
          "name": "marketing_email_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "marketing_sms_consent": {
          "name": "marketing_sms_consent",
          "type": "boolean",
          "primaryKey": false,
          "notNull": false,
          "default": false
        },
        "password_hash": {
          "name": "password_hash",
          "type": "text",
          "primaryKey": false,
          "notNull": true
        },
        "role": {
          "name": "role",
          "type": "varchar(20)",
          "primaryKey": false,
          "notNull": true,
          "default": "'member'"
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "deleted_at": {
          "name": "deleted_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {
        "users_email_unique": {
          "name": "users_email_unique",
          "nullsNotDistinct": false,
          "columns": [
            "email"
          ]
        }
      },
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {},
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}


================================================
FILE: lib/db/migrations/meta/_journal.json
================================================
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1726443359662,
      "tag": "0000_soft_the_anarchist",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "7",
      "when": 1753297708925,
      "tag": "0001_mixed_lilith",
      "breakpoints": true
    },
    {
      "idx": 2,
      "version": "7",
      "when": 1753314242034,
      "tag": "0002_regular_madelyne_pryor",
      "breakpoints": true
    },
    {
      "idx": 3,
      "version": "7",
      "when": 1753315999812,
      "tag": "0003_tidy_omega_flight",
      "breakpoints": true
    },
    {
      "idx": 4,
      "version": "7",
      "when": 1754411170626,
      "tag": "0004_lonely_lethal_legion",
      "breakpoints": true
    }
  ]
}


================================================
FILE: lib/mappings/trec-1-4-data-json.txt
================================================
{
  "parties": {
    "seller": "Seller Name(s)",
    "buyer": "Buyer Name(s) and/or assigns"
  },
  "property": {
    "lot": "Lot Number",
    "block": "Block Number",
    "addition": "Addition Name",
    "city": "City",
    "county": "County",
    "address": "123 Main St, Austin, TX 78701",
    "exclusions": {
      "part1": "List any items to be excluded from the sale.",
      "part2": ""
    },
    "hoaStatus": "is",
    "requiredNotices": "List of required notices, if any."
  },
  "price": {
    "cashPortion": "50000.00",
    "financeAmount": "250000.00",
    "salesPrice": "300000.00"
  },
  "financing": {
    "thirdParty": true,
    "loanAssumption": false,
    "seller": false
  },
  "leases": {
    "isResidential": false,
    "isFixture": false,
    "isNaturalResource": false,
    "naturalResourceTerminationDays": "",
    "naturalResourceDeliveryStatus": "will not be delivered"
  },
  "earnestMoney": {
    "escrowAgentName": "Title Company Name",
    "escrowAgentAddress": {
      "part1": "123 Title Company Lane",
      "part2": "Austin, TX 78704"
    },
    "amount": "3000.00",
    "additionalAmount": "0.00",
    "additionalAmountDays": ""
  },
  "optionFee": {
    "amount": "250.00",
    "days": "10"
  },
  "titlePolicy": {
    "companyName": "Title Company Name",
    "payer": "Seller",
    "shortageAmendment": {
      "status": "shall be amended",
      "payer": "Buyer"
    }
  },
  "survey": {
    "status": "Buyer's Expense",
    "existing": {
      "deliveryDays": "",
      "affidavitPayer": ""
    },
    "new": {
      "deliveryDays": ""
    },
    "newBySeller": {
      "deliveryDays": ""
    }
  },
  "objections": {
    "prohibitedUseActivity": "None",
    "objectionDays": "10"
  },
  "propertyCondition": {
    "sellerDisclosure": {
      "status": "has been received",
      "deliveryDays": ""
    },
    "acceptanceStatus": "as is",
    "repairsList": {
      "part1": "",
      "part2": ""
    }
  },
  "serviceContract": {
    "maxCost": "500.00"
  },
  "brokers": {
    "listing": {
      "associate": {
        "name": "Listing Agent Name",
        "licenseNo": "123456",
        "teamName": "Listing Team",
        "email": "listing.agent@example.com",
        "phone": "512-555-1234"
      },
      "represents": "Seller as Seller's agent",
      "firmName": "Listing Brokerage Firm",
      "firmLicenseNo": "654321",
      "supervisor": {
        "name": "Listing Supervisor Name",
        "licenseNo": "789012"
      },
      "address": {
        "street": "456 Brokerage Blvd",
        "city": "Austin",
        "state": "TX",
        "zip": "78701",
        "phone": "512-555-5678"
      }
    },
    "other": {
      "firmName": "Other Brokerage Firm",
      "firmLicenseNo": "112233",
      "represents": "Buyer as Buyer's agent",
      "associate": {
        "name": "Buyer Agent Name",
        "licenseNo": "445566",
        "teamName": "Buyer Team",
        "email": "buyer.agent@example.com",
        "phone": "512-555-9876"
      },
      "supervisor": {
        "name": "Buyer Supervisor Name",
        "licenseNo": "778899"
      },
      "address": {
        "street": "789 Client Way",
        "city": "Austin",
        "state": "TX",
        "zip": "78704",
        "phone": "512-555-4321"
      }
    },
    "disclosure": {
      "fee": {
        "dollarAmount": "",
        "percentage": "3.0",
        "type": "percentage"
      }
    }
  },
  "closing": {
    "date": {
      "monthDay": "August 30",
      "year": "2025"
    }
  },
  "possession": {
    "status": "closing and funding"
  },
  "specialProvisions": {
    "text": "Buyer is a real estate investor and intends to assign this contract to another buyer. Seller acknowledges this intent."
  },
  "settlement": {
    "sellerContributionToBrokerage": {
      "type": "dollarAmount",
      "dollarAmount": "0.00",
      "percentage": ""
    },
    "sellerContributionToOther": {
      "amount": "0.00"
    }
  },
  "notices": {
    "buyer": {
      "contactInfo": {
        "part1": "Buyer Name",
        "part2": "c/o Buyer's Agent"
      },
      "phone": "512-111-2222",
      "emailFax": {
        "1": "buyer@example.com",
        "2": ""
      }
    },
    "seller": {
      "contactInfo": {
        "part1": "Seller Name",
        "part2": "c/o Seller's Agent"
      },
      "phone": "512-333-4444",
      "emailFax": {
        "1": "seller@example.com",
        "2": ""
      }
    }
  },
  "addenda": {
    "thirdPartyFinancing": true,
    "sellerFinancing": false,
    "hoa": true,
    "buyersTemporaryLease": false,
    "loanAssumption": false,
    "saleOfOtherProperty": false,
    "mineralReservation": false,
    "backupContract": false,
    "coastalAreaProperty": false,
    "hydrostaticTesting": false,
    "lenderAppraisalTermination": false,
    "environmentalAssessment": false,
    "sellersTemporaryLease": false,
    "shortSale": false,
    "seawardOfGulfWaterway": false,
    "leadBasedPaint": true,
    "propaneGasSystem": false,
    "residentialLeases": false,
    "fixtureLeases": false,
    "section1031Exchange": false,
    "improvementDistrict": false,
    "otherText": {
      "p1": ""
    }
  },
  "attorneys": {
    "buyer": {
      "name": "",
      "phone": "",
      "fax": "",
      "email": ""
    },
    "seller": {
      "name": "",
      "phone": "",
      "fax": "",
      "email": ""
    }
  },
  "execution": {
    "day": "5",
    "month": "August",
    "year": "2025"
  }
}



================================================
FILE: lib/mappings/trec-1-4-data.json
================================================
{
  "parties": {
    "seller": "Seller Name(s)",
    "buyer": "Buyer Name(s) and/or assigns"
  },
  "property": {
    "lot": "Lot Number",
    "block": "Block Number",
    "addition": "Addition Name",
    "city": "City",
    "county": "County",
    "address": "123 Main St, Austin, TX 78701",
    "exclusions": {
      "part1": "List any items to be excluded from the sale.",
      "part2": ""
    },
    "hoaStatus": "is",
    "requiredNotices": "List of required notices, if any."
  },
  "price": {
    "cashPortion": "50000.00",
    "financeAmount": "250000.00",
    "salesPrice": "300000.00"
  },
  "financing": {
    "thirdParty": true,
    "loanAssumption": false,
    "seller": false
  },
  "leases": {
    "isResidential": false,
    "isFixture": false,
    "isNaturalResource": false,
    "naturalResourceTerminationDays": "",
    "naturalResourceDeliveryStatus": "will not be delivered"
  },
  "earnestMoney": {
    "escrowAgentName": "Title Company Name",
    "escrowAgentAddress": {
      "part1": "123 Title Company Lane",
      "part2": "Austin, TX 78704"
    },
    "amount": "3000.00",
    "additionalAmount": "0.00",
    "additionalAmountDays": ""
  },
  "optionFee": {
    "amount": "250.00",
    "days": "10"
  },
  "titlePolicy": {
    "companyName": "Title Company Name",
    "payer": "Seller",
    "shortageAmendment": {
      "status": "shall be amended",
      "payer": "Buyer"
    }
  },
  "survey": {
    "status": "Buyer's Expense",
    "existing": {
      "deliveryDays": "",
      "affidavitPayer": ""
    },
    "new": {
      "deliveryDays": ""
    },
    "newBySeller": {
      "deliveryDays": ""
    }
  },
  "objections": {
    "prohibitedUseActivity": "None",
    "objectionDays": "10"
  },
  "propertyCondition": {
    "sellerDisclosure": {
      "status": "has been received",
      "deliveryDays": ""
    },
    "acceptanceStatus": "as is",
    "repairsList": {
      "part1": "",
      "part2": ""
    }
  },
  "serviceContract": {
    "maxCost": "500.00"
  },
  "brokers": {
    "listing": {
      "associate": {
        "name": "Listing Agent Name",
        "licenseNo": "123456",
        "teamName": "Listing Team",
        "email": "listing.agent@example.com",
        "phone": "512-555-1234"
      },
      "represents": "Seller as Seller's agent",
      "firmName": "Listing Brokerage Firm",
      "firmLicenseNo": "654321",
      "supervisor": {
        "name": "Listing Supervisor Name",
        "licenseNo": "789012"
      },
      "address": {
        "street": "456 Brokerage Blvd",
        "city": "Austin",
        "state": "TX",
        "zip": "78701",
        "phone": "512-555-5678"
      }
    },
    "other": {
      "firmName": "Other Brokerage Firm",
      "firmLicenseNo": "112233",
      "represents": "Buyer as Buyer's agent",
      "associate": {
        "name": "Buyer Agent Name",
        "licenseNo": "445566",
        "teamName": "Buyer Team",
        "email": "buyer.agent@example.com",
        "phone": "512-555-9876"
      },
      "supervisor": {
        "name": "Buyer Supervisor Name",
        "licenseNo": "778899"
      },
      "address": {
        "street": "789 Client Way",
        "city": "Austin",
        "state": "TX",
        "zip": "78704",
        "phone": "512-555-4321"
      }
    },
    "disclosure": {
      "fee": {
        "dollarAmount": "",
        "percentage": "3.0",
        "type": "percentage"
      }
    }
  },
  "closing": {
    "date": {
      "monthDay": "August 30",
      "year": "2025"
    }
  },
  "possession": {
    "status": "closing and funding"
  },
  "specialProvisions": {
    "text": "Buyer is a real estate investor and intends to assign this contract to another buyer. Seller acknowledges this intent."
  },
  "settlement": {
    "sellerContributionToBrokerage": {
      "type": "dollarAmount",
      "dollarAmount": "0.00",
      "percentage": ""
    },
    "sellerContributionToOther": {
      "amount": "0.00"
    }
  },
  "notices": {
    "buyer": {
      "contactInfo": {
        "part1": "Buyer Name",
        "part2": "c/o Buyer's Agent"
      },
      "phone": "512-111-2222",
      "emailFax": {
        "1": "buyer@example.com",
        "2": ""
      }
    },
    "seller": {
      "contactInfo": {
        "part1": "Seller Name",
        "part2": "c/o Seller's Agent"
      },
      "phone": "512-333-4444",
      "emailFax": {
        "1": "seller@example.com",
        "2": ""
      }
    }
  },
  "addenda": {
    "thirdPartyFinancing": true,
    "sellerFinancing": false,
    "hoa": true,
    "buyersTemporaryLease": false,
    "loanAssumption": false,
    "saleOfOtherProperty": false,
    "mineralReservation": false,
    "backupContract": false,
    "coastalAreaProperty": false,
    "hydrostaticTesting": false,
    "lenderAppraisalTermination": false,
    "environmentalAssessment": false,
    "sellersTemporaryLease": false,
    "shortSale": false,
    "seawardOfGulfWaterway": false,
    "leadBasedPaint": true,
    "propaneGasSystem": false,
    "residentialLeases": false,
    "fixtureLeases": false,
    "section1031Exchange": false,
    "improvementDistrict": false,
    "otherText": {
      "p1": ""
    }
  },
  "attorneys": {
    "buyer": {
      "name": "",
      "phone": "",
      "fax": "",
      "email": ""
    },
    "seller": {
      "name": "",
      "phone": "",
      "fax": "",
      "email": ""
    }
  },
  "execution": {
    "day": "5",
    "month": "August",
    "year": "2025"
  }
}



================================================
FILE: lib/payments/actions.ts
================================================
'use server';

import { redirect } from 'next/navigation';
import { createCheckoutSession, createCustomerPortalSession } from './stripe';
import { withTeam } from '@/lib/auth/middleware';

export const checkoutAction = withTeam(async (formData, team) => {
  const priceId = formData.get('priceId') as string;
  // This action is for subscriptions, so we don't specify a mode.
  await createCheckoutSession({ team: team, priceId });
});

export const customerPortalAction = withTeam(async (_, team) => {
  const portalSession = await createCustomerPortalSession(team);
  redirect(portalSession.url);
});

// New action for handling one-time credit purchases
export const creditCheckoutAction = withTeam(async (formData, team) => {
  const priceId = formData.get('priceId') as string;
  // We specify 'payment' mode for a one-time purchase
  await createCheckoutSession({ team: team, priceId, mode: 'payment' });
});


================================================
FILE: lib/payments/agents.md
================================================
# Lazily.AI: Payments Module Agent Guide

This `AGENTS.md` provides strict guidance for working within the `lib/payments` directory. This is a high-security area of the application.

## 1. Core Responsibility

This module's sole responsibility is to **securely manage all interactions with the Stripe API**. This includes initiating payments and handling the logic for what happens after a payment is confirmed via webhook.

## 2. Security & Best Practices

* **NEVER hardcode secrets.** All Stripe API keys and secrets **must** be accessed from environment variables (`process.env`).
* When creating a Stripe Checkout Session (`createCheckoutSession`), you **must** pass the `user.id` as the `client_reference_id` and the `team.id` in the `metadata`. This is critical for linking the Stripe transaction back to our database records during webhook processing.
* All business logic for fulfilling a purchase (e.g., updating a team's credit balance or subscription status) belongs in the handler functions within `stripe.ts` (e.g., `handleCreditPurchase`, `handleSubscriptionChange`).

## 3. Key File Directives

* **`stripe.ts`**:
    * This is the **only file** that should directly interact with the Stripe Node.js client.
    * The `createCheckoutSession` function must clearly differentiate between `mode: 'subscription'` for recurring plans and `mode: 'payment'` for one-time credit purchases. The success and cancel URLs should be appropriate for each mode.
* **`actions.ts`**:
    * These server actions are the bridge from the UI to the payment logic.
    * They should be simple wrappers that extract the `priceId` from the form data and call `createCheckoutSession` with the correct parameters.
    * Do not place any complex business logic within these actions; delegate it to the functions in `stripe.ts`.


================================================
FILE: lib/payments/stripe.ts
================================================
import Stripe from 'stripe';
import { redirect } from 'next/navigation';
import { Team, ActivityType } from '@/lib/db/schema';
import {
  getTeamByStripeCustomerId,
  getUser,
  updateTeamSubscription,
  createActivityLog,
  getTeamOwner
} from '@/lib/db/queries';
import { db } from '../db/drizzle';
import { teams } from '../db/schema';
import { eq } from 'drizzle-orm';

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2025-04-30.basil'
});

// This function is now updated to handle both 'subscription' and 'payment' modes
export async function createCheckoutSession({
  team,
  priceId,
  mode = 'subscription' // Default to 'subscription' for backward compatibility
}: {
  team: Team | null;
  priceId: string;
  mode?: 'subscription' | 'payment'; // Allow specifying the checkout mode
}) {
  const user = await getUser();
  if (!team || !user) {
    redirect(`/sign-up?redirect=checkout&priceId=${priceId}`);
  }

  // Determine success URL based on checkout mode
  const successUrlPath = mode === 'subscription' 
    ? '/api/stripe/checkout?session_id={CHECKOUT_SESSION_ID}' 
    : '/dashboard/billing?success=true';
  
  const cancelUrlPath = mode === 'subscription' ? '/pricing' : '/dashboard/billing';

  const session = await stripe.checkout.sessions.create({
    payment_method_types: ['card'],
    line_items: [
      {
        price: priceId,
        quantity: 1
      }
    ],
    mode: mode, // Use the new 'mode' parameter
    success_url: `${process.env.BASE_URL}${successUrlPath}`,
    cancel_url: `${process.env.BASE_URL}${cancelUrlPath}`,
    customer: team.stripeCustomerId || undefined,
    client_reference_id: user.id.toString(),
    allow_promotion_codes: true,
  });

  redirect(session.url!);
}

export async function createCustomerPortalSession(team: Team) {
  if (!team.stripeCustomerId || !team.stripeProductId) {
    redirect('/pricing');
  }

  let configuration: Stripe.BillingPortal.Configuration;
  const configurations = await stripe.billingPortal.configurations.list();
  if (configurations.data.length > 0) {
    configuration = configurations.data[0];
  } else {
    const product = await stripe.products.retrieve(team.stripeProductId);
    if (!product.active) {
      throw new Error("Team's product is not active in Stripe");
    }

    const prices = await stripe.prices.list({
      product: product.id,
      active: true
    });
    if (prices.data.length === 0) {
      throw new Error("No active prices found for the team's product");
    }

    configuration = await stripe.billingPortal.configurations.create({
      business_profile: {
        headline: 'Manage your subscription'
      },
      features: {
        subscription_update: {
          enabled: true,
          default_allowed_updates: ['price', 'quantity', 'promotion_code'],
          proration_behavior: 'create_prorations',
          products: [
            {
              product: product.id,
              prices: prices.data.map((price) => price.id)
            }
          ]
        },
        subscription_cancel: {
          enabled: true,
          mode: 'at_period_end',
          cancellation_reason: {
            enabled: true,
            options: [
              'too_expensive',
              'missing_features',
              'switched_service',
              'unused',
              'other'
            ]
          }
        },
        payment_method_update: {
          enabled: true
        }
      }
    });
  }

  return stripe.billingPortal.sessions.create({
    customer: team.stripeCustomerId,
    return_url: `${process.env.BASE_URL}/dashboard`,
    configuration: configuration.id
  });
}

export async function handleSubscriptionChange(
  subscription: Stripe.Subscription,
  eventType: 'customer.subscription.updated' | 'customer.subscription.deleted'
) {
  const customerId = subscription.customer as string;
  const subscriptionId = subscription.id;
  const status = subscription.status;

  const team = await getTeamByStripeCustomerId(customerId);

  if (!team) {
    console.error('Team not found for Stripe customer:', customerId);
    return;
  }

  if (status === 'active' || status === 'trialing') {
    const plan = subscription.items.data[0]?.plan;
    await updateTeamSubscription(team.id, {
      stripeSubscriptionId: subscriptionId,
      stripeProductId: plan?.product as string,
      planName: (plan?.product as Stripe.Product).name,
      subscriptionStatus: status
    });

    if (eventType === 'customer.subscription.updated') {
      const owner = await getTeamOwner(team.id);
      if (owner) {
        await createActivityLog({
          teamId: team.id,
          userId: owner.id,
          action: ActivityType.MEMBERSHIP_RENEWAL,
        });
      }
    }

  } else if (status === 'canceled' || status === 'unpaid') {
    await updateTeamSubscription(team.id, {
      stripeSubscriptionId: null,
      stripeProductId: null,
      planName: null,
      subscriptionStatus: status
    });
  }
}

export async function handleSubscriptionPurchase(session: Stripe.Checkout.Session) {
  const customerId = session.customer as string;
  const team = await getTeamByStripeCustomerId(customerId);

  if (!team) {
    console.error('Team not found for Stripe customer:', customerId);
    return;
  }

  const userId = parseInt(session.client_reference_id!);
  if (userId) {
      await createActivityLog({
        teamId: team.id,
        userId: userId,
        action: ActivityType.MEMBERSHIP_PURCHASE,
      });
  }
}

export async function handleCreditPurchase(session: Stripe.Checkout.Session) {
  const customerId = session.customer as string;
  const team = await getTeamByStripeCustomerId(customerId);

  if (!team) {
    console.error('Team not found for Stripe customer:', customerId);
    return;
  }

  const lineItems = await stripe.checkout.sessions.listLineItems(session.id);
  const priceId = lineItems.data[0].price?.id;

  // This is a simplified way to determine credits from price.
  // In a real application, you might have this mapping in your database or config.
  let creditsPurchased = 0;
  if (priceId === process.env.STRIPE_CREDITS_PRICE_ID_100) {
    creditsPurchased = 100;
  } else if (priceId === process.env.STRIPE_CREDITS_PRICE_ID_500) {
    creditsPurchased = 500;
  }

  if (creditsPurchased > 0) {
    await db.update(teams).set({
      contractCredits: (team.contractCredits || 0) + creditsPurchased
    }).where(eq(teams.id, team.id));

    const userId = parseInt(session.client_reference_id!);
    if (userId) {
      await createActivityLog({
        teamId: team.id,
        userId: userId,
        action: ActivityType.CREDIT_PURCHASE,
      });
    }
  }
}

export async function getStripePrices() {
  const prices = await stripe.prices.list({
    expand: ['data.product'],
    active: true,
    type: 'recurring'
  });
  return prices.data.map((price) => ({
    id: price.id,
    productId:
      typeof price.product === 'string' ? price.product : price.product.id,
    unitAmount: price.unit_amount,
    currency: price.currency,
    interval: price.recurring?.interval,
    trialPeriodDays: price.recurring?.trial_period_days
  }));
}

export async function getStripeProducts() {
  const products = await stripe.products.list({
    active: true,
    expand: ['data.default_price']
  });
  return products.data.map((product) => ({
    id: product.id,
    name: product.name,
    description: product.description,
    defaultPriceId:
      typeof product.default_price === 'string'
        ? product.default_price
        : product.default_price?.id
  }));
}


================================================
FILE: lib/properties/queries.ts
================================================
// lib/properties/queries.ts

import { db } from '../db/drizzle';
import { properties, type Property } from '../db/schema'; // CORRECTED IMPORT

export async function fetchProperties(): Promise<Property[]> {
  try {
    const data = await db.select().from(properties);
    return data;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch properties.');
  }
}


================================================
FILE: lib/properties/validation.ts
================================================
import { z } from 'zod';

export const propertySchema = z.object({
  streetAddress: z.string().min(1, 'Street address is required'),
  city: z.string().min(1, 'City is required'),
  zipCode: z.string().min(1, 'Zip code is required'),
  offerPrice: z.string().min(1, 'Offer price is required'),
  ownerId: z.number().int().positive('Owner ID must be a positive integer'),
  teamId: z.number().int().positive('Team ID must be a positive integer'),
});



================================================
FILE: lib/styles/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


================================================
FILE: posts/guide-to-texas-option-fee.mdx
================================================
    ---
    title: "A Step-by-Step Guide to the Texas Option Fee"
    date: "2025-07-29"
    description: "Understand the purpose, mechanics, and strategic importance of the Option Fee and Option Period in the Texas TREC 1-4 contract. A must-read for any buyer."
    ---

    In Texas real estate, the "Option Period" is a critical, buyer-friendly feature of the TREC 1-4 contract. It's a negotiated window of time during which the buyer has the unrestricted right to terminate the contract for any reason. This right is purchased for a fee, known as the Option Fee.

    ### What is the Option Fee?

    The Option Fee is a non-refundable amount paid by the buyer directly to the seller. It is consideration for the seller taking the property off the market for the duration of the Option Period.

    - **Amount:** The fee is negotiable. It can be anything from $100 to several thousand dollars, depending on the price of the home and market conditions.
    - **Delivery:** Per Paragraph 5 of the contract, the Option Fee must be delivered to the Escrow Agent within 3 days of the contract's Effective Date.

    ### How Termination Works

    If the buyer decides to terminate, they must give written notice to the seller *before* 5:00 PM (local time where the property is located) on the last day of the Option Period.

    - **If you terminate:** You lose the Option Fee (the seller keeps it), but your Earnest Money is refunded.
    - **If you proceed:** The Option Fee is typically credited to the sales price at closing.

    The Option Period is one of the most powerful tools a buyer has in Texas. It provides a low-cost "out" if the property isn't what it seems, making it an essential part of a smart and safe real estate purchase.
    


================================================
FILE: posts/how-to-fill-trec-1-4-wholesale.mdx
================================================
    ---
    title: "How to Fill Out the TREC 1-4 Contract for a Wholesale Deal"
    date: "2025-07-29"
    description: "A comprehensive, field-by-field guide for Texas real estate investors on correctly completing the TREC 1-4 Family Residential Contract for a wholesale transaction."
    ---

    The TREC 1-4 Family Residential Contract is the bedrock of most residential real estate deals in Texas. For wholesalers, mastering this form isn't just about compliance; it's about creating a clear, enforceable agreement that protects your interests and facilitates a smooth assignment. This guide will walk you through the critical fields from a wholesaler's perspective.

    ### Section 1: Parties

    This seems simple, but it's where the foundation is laid.

    - **Seller:** This is the current owner of the property. Ensure the name matches the deed exactly.
    - **Buyer:** This is **your entity** (e.g., "Your Investing LLC") or your name. Crucially, you should add `"and/or assigns"` after your name or entity. This language explicitly puts the seller on notice that you may assign your rights in the contract to another buyer. Example: `John Doe and/or assigns`.

    ### Section 5: Earnest Money and Option Fee

    This is where you demonstrate seriousness and secure your exit ramp.

    - **Earnest Money:** A reasonable amount to show good faith. For many wholesale deals, this can be as low as $100 to $500.
    - **Option Fee & Period:** This is a wholesaler's most powerful tool. Pay a nominal Option Fee (e.g., $100) for an Option Period of at least 14-30 days. This gives you the unrestricted right to terminate the contract for any reason, providing you time to find an end-buyer without being locked in.

    ### Section 11: Special Provisions

    **Crucial rule:** Real estate agents are prohibited from adding business details here, but as a principal in the transaction (the buyer), you can. This is where you can add specific wholesaling clauses. A common one is a disclosure clause:

    > "Buyer is a real estate investor and intends to assign this contract to another buyer. Seller acknowledges this intent."

    This provides full transparency and can prevent disputes later.
    


================================================
FILE: public/templates/lazily-ai-template.csv
================================================
parties.seller,parties.buyer,property.lot,property.block,property.addition,property.city,property.county,property.address,property.exclusions.part1,property.exclusions.part2,property.hoaStatus,price.cashPortion,price.financeAmount,price.salesPrice,financing.thirdParty,financing.loanAssumption,financing.seller,leases.isResidential,leases.isFixture,leases.isNaturalResource,earnestMoney.escrowAgentName,earnestMoney.escrowAgentAddress.part1,earnestMoney.amount,earnestMoney.additionalAmount,earnestMoney.additionalAmountDays,optionFee.amount,optionFee.days,titlePolicy.companyName,titlePolicy.payer,titlePolicy.shortageAmendment.status,titlePolicy.shortageAmendment.payer,survey.status,objections.objectionDays,propertyCondition.sellerDisclosure.status,propertyCondition.sellerDisclosure.deliveryDays,propertyCondition.acceptanceStatus,propertyCondition.repairsList.part1,brokers.listing.associate.name,brokers.listing.associate.licenseNo,brokers.listing.firmName,brokers.listing.firmLicenseNo,brokers.other.associate.name,brokers.other.associate.licenseNo,brokers.other.firmName,brokers.other.firmLicenseNo,closing.date.monthDay,closing.date.year,possession.status,specialProvisions.text,settlement.sellerContributionToOther.amount,notices.buyer.contactInfo.part1,notices.seller.contactInfo.part1,addenda.thirdPartyFinancing,addenda.sellerFinancing,addenda.hoa,addenda.buyersTemporaryLease,addenda.loanAssumption,addenda.saleOfOtherProperty,addenda.leadBasedPaint,addenda.sellersTemporaryLease,addenda.otherText.p1,attorneys.buyer.name,attorneys.buyer.phone,attorneys.buyer.email,attorneys.seller.name,attorneys.seller.phone,attorneys.seller.email,execution.day,execution.month,execution.year

